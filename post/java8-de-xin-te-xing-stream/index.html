<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>F4DE的博客</title>
<meta name="description" content="Keep fantasy" />
<link rel="shortcut icon" href="https://f4de-bak.github.io/favicon.ico?v=1614848448352">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://f4de-bak.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://f4de-bak.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://f4de-bak.github.io/images/avatar.png?v=1614848448352" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">F4DE的博客</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#lambda-function">Lambda Function</a>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F">一般形式</a></li>
<li><a href="#functionalinterface">FunctionalInterface</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8">方法引用</a></li>
</ul>
</li>
<li><a href="#stream">Stream</a>
<ul>
<li><a href="#steam%E4%BB%8B%E7%BB%8D">Steam介绍</a></li>
<li><a href="#intermediate-operation">Intermediate operation</a>
<ul>
<li><a href="#map">map</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#distinct">distinct</a></li>
</ul>
</li>
<li><a href="#ternimal-operations">Ternimal operations</a>
<ul>
<li><a href="#foreach">forEach</a></li>
<li><a href="#reduce">reduce</a></li>
</ul>
</li>
<li><a href="#other-features">Other features</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.2s">
          标签
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.4s">
          归档
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="/post/links" class="menu" style="animation-delay: 0.8s">
          友链
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://f4de-bak.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Java8的新特性-Stream</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2021-02-25 / 14 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210225154829.jpg" alt="">
        
        <div class="post-content yue">
          <p>流（stream）是Java8中的一个重要特性，利用匿名函数和流可以极大简化一些繁琐的操作。</p>
<!-- more -->
<h2 id="lambda-function">Lambda Function</h2>
<h3 id="一般形式">一般形式</h3>
<p>lambda的一般形式，由两部分组成：</p>
<pre><code class="language-java">(par1, par2···) -&gt; {
    // code block
    return xxx；
}

</code></pre>
<p><code>(par1, par2···)</code>表示参数，类型可以省略，因为编译器可以自动推断出参数类型，<code>{···}</code>中间的内容表示方法体，就是要执行的代码。</p>
<p>如果方法体中只有一行<code>return xxx</code>的代码，那么完全可以更加简洁：</p>
<pre><code>(par1, par2···) -&gt; xxx;

</code></pre>
<p>比如下面的例子：</p>
<pre><code>(s1, s2) -&gt; {
    return s1.equals(s2);
}

// 等同于

(s1, s2) -&gt; s1.equals(s2);

</code></pre>
<p>函数返回值的类型也是由编译器自动判断的。</p>
<h3 id="functionalinterface">FunctionalInterface</h3>
<p>由于lambda创建了一个匿名函数，我们可以把这个函数交给一个变量，然后利用这个变量去执行我们写好的函数，比如在python中，我们可以这样做：</p>
<pre><code>In [1]: func = lambda x : x+2

In [2]: print(func(1))
3

</code></pre>
<p>但由于Java是强类型语言，在基本类型和引用类型中没有一个用来表示“这个变量是一个函数”的类型，但是Java8为我们提供一种<code>函数接口</code>，一个lambda表达式可以赋值给一个函数接口的对象，然后利用这个对象去调用lambda表达式。</p>
<p>我们可以使用注解<code>@FunctionalInterface</code>来定义一个函数接口，比如这样：</p>
<pre><code class="language-java">@FunctionalInterface
interface LambdaFunc {
    boolean strCompare(String s1, String s2);
}

public class Demo1 {
    public static void main(String[] args) {
        LambdaFunc test = (s1, s2) -&gt; s1.equals(s2);

        System.out.println(test.strCompare(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p>一个函数接口具有一下特点：</p>
<ol>
<li>函数接口是单（抽象）方法接口</li>
<li>接口中抽象方法的返回值就是我们所写的lambda表达式中函数体的返回值</li>
<li>接口中抽象方法的参数就是我们所写的lambda表达式中的参数</li>
<li>只有显式调用<code>函数接口对象.抽象方法</code>并传入相应的参数才会调用对应的lambda表达式</li>
</ol>
<p>其实有些函数接口我们没有必要自己实现，Java8中的<code>java.util.function</code>包中给我们提供了很多的函数接口，比如下面这样：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        BiPredicate&lt;String, String&gt; function = (String s1, String s2) -&gt; s1.equals(s2);

        System.out.println(function.test(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p><code>BiPredicate</code>就是一个<code>function</code>包中内置的一个函数接口，它的抽象方法会接受两个参数，并且返回布尔值：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210104112204.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210104112204.png" loading="lazy"></figure>
<h3 id="方法引用">方法引用</h3>
<p>上面的例子还可以进一步化简：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        BiPredicate&lt;String, String&gt; function = String::equals;

        System.out.println(function.test(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p>我们把<code>(String s1, String s2) -&gt; s1.equals(s2)</code>简化成了<code>String::equals</code>，这种简化方式称作方法引用，所谓方法引用，就是某个方法的签名和接口的抽象方法签名恰好一致，那么就可以直接把方法引用作为lambda表达式传入接口。</p>
<pre><code>s -&gt; System.out.println(s)  &lt;==&gt;  System.out::println

</code></pre>
<h2 id="stream">Stream</h2>
<p><a href="https://www.youtube.com/watch?v=t1-YZ6bF-g0">Java 8 STREAMS Tutorial - YouTube</a></p>
<h3 id="steam介绍">Steam介绍</h3>
<blockquote>
<p>Stream（流）是Java8中引入的全新API</p>
</blockquote>
<p>Steam本身并不会保存数据，而是类似于一个比较高级的迭代器，数据源中的元素单向传递到流中，不可以往复，只能遍历一次，就像水流一样一去不复返。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175021.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175021.png" loading="lazy"></figure>
<p>在图中涉及到了两个名词：<em>Intermediate operations</em>和<em>Ternimal operations</em>，这是流中的两个重要操作。</p>
<p>Stream分为中间操作(Intermediate operations)和终端操作(Ternimal operations)：</p>
<ul>
<li>中间操作用于对流进行过滤、转换、排序等，比如<code>filter</code>、<code>map</code>、<code>sort</code>，多个中间操作可以被串联起来，一个流经过中间操作之后还是一个流。</li>
<li>终端操作用于将流转换为其他Java对象，比如<code>forEach</code>、<code>collect</code>、<code>reduce</code>等。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175251.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175251.png" loading="lazy"></figure>
<p>一个流中可以有零个或者多个中间操作，对于比较大的数据集：我们应该遵循的一个原则是先使用<code>filter</code>将其过滤，然后再使用其他的中间操作比如<code>map</code>、<code>sort</code>等。</p>
<p>一个流只能有一个终端操作，一些常用的终端操作作用如下：</p>
<ul>
<li><code>forEach</code>：对于对于每个流中的元素使用相同的函数</li>
<li><code>collect</code>：将流中的元素汇总到一个集合里</li>
<li>······</li>
</ul>
<p>在使用stream的时候，基本会遵循下面三个步骤：</p>
<ol>
<li>创建stream</li>
<li>进行流的转换，返回一个新的stream对象（链式操作）</li>
<li>将流转换为其他Java对象</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175912.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175912.png" loading="lazy"></figure>
<p>一个流可以通过<code>Collections</code>、<code>Lists</code>、<code>Sets</code>、<code>ints</code>、<code>longs</code>、<code>doubles</code>、<code>arrays</code>、<code>lines of file</code>创建出来。</p>
<h3 id="intermediate-operation">Intermediate operation</h3>
<p>intermediate ooperation（中间操作）：一个流后面可以串联一个或多个中间操作。中间操作可以打开流，对流中的数据进行过滤、映射等，并返回一个新的流供之后操作实用。</p>
<h4 id="map">map</h4>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(1, 2, 3, 4, 5, 6).map(x -&gt; x + 2).forEach(System.out::println);

    }
}

/*
3
4
5
6
7
8

Process finished with exit code 0
*/

</code></pre>
<p>中间操作<code>map</code>用于将一个对象转换为另一个对象，它的签名要求实现一个<code>Function</code>函数接口：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106122927.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106122927.png" loading="lazy"></figure>
<p>这个函数接口的静态方法是接受一个T类型的参数，然后返回一个R类型的对象：</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123014.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123014.png" loading="lazy"></figure>
<p>对于上面的例子，我们做的操作就是把X + 2，所以T和R都是<code>Integer</code>。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(1, 2, 3, 4, 5, 6).map(String::valueOf).forEach(s -&gt; System.out.println(s.getClass().getName()));

    }
}

/*
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String

Process finished with exit code 0

</code></pre>
<p>对于这个例子来说，T就是<code>Integer</code>，R就是<code>String</code>。</p>
<h4 id="filter">filter</h4>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;AI&quot;, &quot;Ankit&quot;, &quot;Kushal&quot;, &quot;Bob&quot;, &quot;Susan&quot;, &quot;Hans&quot;).filter(s -&gt; s.startsWith(&quot;A&quot;)).forEach(System.out::println);

    }
}

/*
AI
Ankit

Process finished with exit code 0

</code></pre>
<p><code>filter</code>是一个过滤器，可以通过给定的条件把流中不符合条件的元素剔除掉，它的签名要求我们实现一个<code>Predicate</code>函数接口，这个函数接口的静态方法接收一个T类型的参数，而返回一个布尔值：</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123958.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123958.png" loading="lazy"></figure>
<p>下一个例子，通过map将流中的每个元素首字母转换为小写，然后再用filter过滤出符合条件的元素：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;AI&quot;, &quot;Ankit&quot;, &quot;Kushal&quot;, &quot;Bob&quot;, &quot;Susan&quot;, &quot;Hans&quot;).map(String::toLowerCase).filter(s -&gt; s.startsWith(&quot;a&quot;)).forEach(System.out::println);

    }
}

/*
ai
ankit

Process finished with exit code 0

</code></pre>
<h4 id="distinct">distinct</h4>
<p>对于流中的元素进行去重，不需要先把其转换为<code>Set</code>，只需要实用<code>distinct</code>中间操作即可：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5, 1);
        list.stream().distinct().forEach(System.out::println);

    }
}

/*
1
2
3
4
5

</code></pre>
<h3 id="ternimal-operations">Ternimal operations</h3>
<p>Ternimal operations（终端操作）：终端操作是流的链式调用的最后一步，被终端操作处理过的流就会变成其他的Java对象。在一个流的链式调用流程中，终端操作只会被调用一次，调用之后流就会关闭。</p>
<h4 id="foreach">forEach</h4>
<p><code>forEach</code>是最常用的一个终端操作，它的参数是一个<code>Consumer</code>函数接口（一元），对流中的每一个元素执行相同的操作，最常见的就是打印流中的每个元素：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        Stream.of(1, 2, 3, 4, 5).map(x -&gt; x + 1).forEach(System.out::println);
    }
}

/*
2
3
4
5
6

</code></pre>
<h4 id="reduce">reduce</h4>
<p>reduce（聚合）操作可以通过聚合函数把流中的元素聚合成一个结果。</p>
<p>reduce方法传入的是一个<code>BinaryOperator</code>接口对象，它的<code>apply</code>方法是一个二元抽象方法，会把传入的两个参数进行运算，并返回运算的结果：</p>
<pre><code class="language-java">T apply(T t, T u);

</code></pre>
<p>下面的代码实用了聚合操作来进行求和：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Integer integer = Stream.of(1, 2, 3, 4, 5).reduce(0, (sum, i) -&gt; sum + i);
        System.out.println(&quot;integer = &quot; + integer);

    }
}

/*
integer = 15

</code></pre>
<p>这样似乎不是很好理解，可以使用for循环来改写一下上面的代码：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) throws Exception {
        int[] arrays = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int i : arrays) {
            System.out.printf(&quot;sum = sum + i = %d + %d\n&quot;, sum, i);
            sum += i;
        }
        System.out.println(sum);
    }

</code></pre>
<p>值得注意的是，我们上面的代码在reduce方法中传入一个初始值0，这样一来，在第一轮中，0就会被作为函数<code>(sum, i) -&gt; sum + i</code>中sum的初始值，而i的初始值就是Stream中的第一个元素<code>1</code>，执行完第一轮的结果为<code>0 + 1 = 1</code>，而这个结果又会作为第二轮中<code>sum</code>的初始值，<code>i</code>的值为Stream中的第二个元素<code>2</code>，如此达到了累加的效果。</p>
<pre><code>sum = sum + i = 0 + 1 = 1
sum = sum + i = 1 + 2 = 3
sum = sum + i = 3 + 3 = 6
sum = sum + i = 6 + 4 = 10
sum = sum + i = 10 + 5 = 15
15

</code></pre>
<p>此外，reduce方法还可以不传入初始值，这样一来，第一轮中的<code>sum</code>的初始值就变为了Stream中的第一个元素<code>1</code>，<code>i</code>的初始值就变成了Stream中的第二个元素<code>2</code>；reduce操作返回的结果也变成了<code>Optional&lt;Integer&gt;</code>对象，需要多调用一个get方法才能得到运算的结果。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) throws Exception {
        Optional&lt;Integer&gt; integer = Stream.of(1, 2, 3, 4, 5).reduce((sum, i) -&gt; sum + i);
        System.out.println(&quot;integer = &quot; + integer.get());
    }
}

/*
integer = 15

</code></pre>
<pre><code class="language-java">sum = sum + i = 1 + 2 = 3
sum = sum + i = 3 + 3 = 6
sum = sum + i = 6 + 4 = 10
sum = sum + i = 10 + 5 = 15
15

</code></pre>
<p>灵活使用reduce，可以达到一些神奇的效果，比如把配置文件中的<code>key=value</code>这种形式的字符串作为键值对储存在Map中：</p>
<pre><code class="language-java">public class Demo2 {
    public static void main(String[] args) {
        List&lt;String&gt; props = List.of(&quot;profile=native&quot;, &quot;debug=true&quot;, &quot;logging=warn&quot;, &quot;interval=500&quot;);
        Map&lt;String, String&gt; propMap = props.stream().map(line -&gt; {
            String[] split = line.split(&quot;=&quot;);
            return Map.of(split[0], split[1]);
        }).reduce(new HashMap&lt;String, String&gt;(), (map, kvmap) -&gt; {
            System.out.println(kvmap.toString() + &quot; -&gt; HashMap&quot;);
            map.putAll(kvmap);
            return map;
        });

        propMap.forEach((key, value) -&gt; {
            System.out.println(key + &quot;: &quot; + value);
        });
    }
}

</code></pre>
<pre><code class="language-java">{profile=native} -&gt; HashMap
{debug=true} -&gt; HashMap
{logging=warn} -&gt; HashMap
{interval=500} -&gt; HashMap
logging: warn
interval: 500
debug: true
profile: native

</code></pre>
<h3 id="other-features">Other features</h3>
<p>Stream具有延时性：只有当终端操作存在的时候，中间的操作才会被执行。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        
        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;).filter(s -&gt; {
            System.out.println(&quot;filter: &quot; + s);
            return true;
        });

    }
}

// 不打印结果

public class Demo1 {
    public static void main(String[] args) {
        
        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;).filter(s -&gt; {
            System.out.println(&quot;filter: &quot; + s);
            return true;
        }).forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));

    }
}

/*
filter: a1
forEach: a1
filter: a2
forEach: a2
filter: a3
forEach: a3
filter: a4
forEach: a4

Process finished with exit code 0
*/

</code></pre>
<p>这样设计是出于性能的考虑，Stream垂直执行可以减少对每个元素的操作个数</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;).map(x -&gt; {
            System.out.println(&quot;map: &quot; + x);
            return x.toUpperCase();
        }).anyMatch(x -&gt; {
            System.out.println(&quot;anyMatch: &quot; + x);
            return x.startsWith(&quot;B&quot;);
        });

    }
}

/*
map: a1
anyMatch: A1
map: b1
anyMatch: B1
*/

</code></pre>
<p><code>anyMatch()</code>方法是一个聚合操作，和中间操作<code>filter()</code>类似，可以传入一个返回值为布尔类型的lambda表达式，当表达式返回值为True的时候就结束循环。</p>
<p>Stream是不能复用的，当调用聚合操作之后流就关闭了，此时如果再调用流则会抛出异常。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream&lt;String&gt; stream = Stream.of(&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;).map(x -&gt; {
            System.out.println(&quot;map: &quot; + x);
            return x.toUpperCase();
        });
        stream.anyMatch(s -&gt; {
            System.out.println(&quot;Stream close&quot;);
            return true;
        });
        stream.filter(s -&gt; true);

    }
}

/*
map: a1
Stream close
Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed
  at java.util.stream.AbstractPipeline.&lt;init&gt;(AbstractPipeline.java:203)
  at java.util.stream.ReferencePipeline.&lt;init&gt;(ReferencePipeline.java:94)
  at java.util.stream.ReferencePipeline$StatelessOp.&lt;init&gt;(ReferencePipeline.java:618)
  at java.util.stream.ReferencePipeline$2.&lt;init&gt;(ReferencePipeline.java:163)
  at java.util.stream.ReferencePipeline.filter(ReferencePipeline.java:162)
  at steam.Demo1.main(Demo1.java:18)
*/

</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://f4de-bak.github.io/tag/Mxwmpq9ir/">
            <span class="flex-auto">Java</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://f4de-bak.github.io/post/java-zi-jie-ma-wen-jian-jie-gou/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  Java字节码文件结构
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://f4de-bak.github.io/post/bo-ke-chong-jian/">
                <h3 class="post-title">
                  博客重建
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://f4de-bak.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
