<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://f4de-bak.github.io</id>
    <title>F4DE的博客</title>
    <updated>2021-03-22T09:22:58.341Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://f4de-bak.github.io"/>
    <link rel="self" href="https://f4de-bak.github.io/atom.xml"/>
    <subtitle>Keep fantasy</subtitle>
    <logo>https://f4de-bak.github.io/images/avatar.png</logo>
    <icon>https://f4de-bak.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, F4DE的博客</rights>
    <entry>
        <title type="html"><![CDATA[Shiro复盘--权限绕过（三）]]></title>
        <id>https://f4de-bak.github.io/post/8Mpx_LGdo/</id>
        <link href="https://f4de-bak.github.io/post/8Mpx_LGdo/">
        </link>
        <updated>2021-03-20T15:20:34.000Z</updated>
        <summary type="html"><![CDATA[<p>Shiro漏洞复盘系列--1.5.3版本以下的权限绕过复现分析。（CVE-2020-11989）</p>
]]></summary>
        <content type="html"><![CDATA[<p>Shiro漏洞复盘系列--1.5.3版本以下的权限绕过复现分析。（CVE-2020-11989）</p>
<!-- more -->
<h1 id="简介">简介</h1>
<p>漏洞影响范围：shiro &lt; 1.5.3</p>
<p>利用条件：</p>
<ul>
<li><em>Spring</em> 需要设置 <em>ContextPath</em></li>
</ul>
<ul>
<li><em>alwaysUseFullPath</em> 必须设置为 <em>false</em></li>
</ul>
<h1 id="配置">配置</h1>
<p>Spring的版本配置有坑点，主要与的<code>alwaysUseFullPath</code>值有关。</p>
<pre><code class="language-xml">    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
&lt;!--        &lt;version&gt;2.4.3&lt;/version&gt;--&gt;
        &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

        &lt;!-- shiro dependence --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;
            &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
            &lt;version&gt;1.5.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h1 id="分析">分析</h1>
<p>设置 <code>context-path</code> 为 <code>test</code>：</p>
<figure data-type="image" tabindex="1"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321230516.png" alt="image-20210321230509651" loading="lazy"></figure>
<p>访问<code>/test/admin</code>，被shiro拦截：</p>
<figure data-type="image" tabindex="2"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321230614.png" alt="image-20210321230614028" loading="lazy"></figure>
<p>访问<code>/;/test/admin</code>，绕过shiro鉴权：</p>
<figure data-type="image" tabindex="3"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321230654.png" alt="image-20210321230654282" loading="lazy"></figure>
<h2 id="shiro">shiro</h2>
<p>依然是在<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>这个方法打下断点，调试shiro来处理URL请求的过程，跟进<code>getPathWithinApplication</code>方法：</p>
<figure data-type="image" tabindex="4"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321231919.png" alt="image-20210321231919360" loading="lazy"></figure>
<p>通过<code>gerRequestUri</code>方法获得的结果是<code>/</code>：</p>
<figure data-type="image" tabindex="5"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321233255.png" alt="image-20210321233254981" loading="lazy"></figure>
<p>所以跟进到该方法内部调试，在<code>1.5.2</code>的补丁版本中我们知道URL的获取规则变成了<code>ContextPath</code>、<code>ServletPath</code>、<code>PathInfo</code>三者拼接而成：</p>
<figure data-type="image" tabindex="6"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321233426.png" alt="image-20210321233426337" loading="lazy"></figure>
<p>问题就处在<code>getContextPath</code>方法中，经过这个方法之后可以获得带<code>;</code>号的<code>ContextPath</code>：</p>
<figure data-type="image" tabindex="7"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321234141.png" alt="image-20210321234141918" loading="lazy"></figure>
<p>三者拼接之后URL为<code>/;/test//admin</code>，之后传入<code>decodeAndCleanUriString</code>方法中，仅仅保留了<code>;</code>号前面的部分：</p>
<figure data-type="image" tabindex="8"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321234354.png" alt="image-20210321234353933" loading="lazy"></figure>
<p>那么由shiro处理完成之后的结果就是<code>/</code>，从而绕过了shiro鉴权：</p>
<figure data-type="image" tabindex="9"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210321234545.png" alt="image-20210321234545785" loading="lazy"></figure>
<h2 id="spring">Spring</h2>
<p>Spring 是否调用 <code>getPathWithinServletMapping</code> 方法和 <code>alwaysUseFullPath</code> 的值有关，Spring官方称该值默认为 false，但是我在使用最新版Spring的时候却是默认为 true ，导致漏洞无法复现（待解决），下面两张图是不同版本的Spring的差异。</p>
<p>5.2.5版本的Spring：</p>
<figure data-type="image" tabindex="10"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210322081855.png" alt="image-20210322081854865" loading="lazy"></figure>
<p>5.3.4版本的Spring：</p>
<figure data-type="image" tabindex="11"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210322171135.png" alt="image-20210322171135294" loading="lazy"></figure>
<p>只有当<code>alwaysUseFullPath</code>为<code>false</code>的情况下才会进入<code>getPathWithinServletMapping</code>中，经过<code>getPathWithinServletMapping</code>处理之后可以正确获取到路径：</p>
<figure data-type="image" tabindex="12"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210322082728.png" alt="image-20210322082728818" loading="lazy"></figure>
<p><code>getPathWithinApplication</code>方法中的处理逻辑在上一篇中已经分析过，这里不再赘述，<code>getServletPath</code>方法获取到的其实是<code>Request</code>对象的某个属性值：</p>
<figure data-type="image" tabindex="13"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210322083656.png" alt="image-20210322083656733" loading="lazy"></figure>
<h1 id="修复">修复</h1>
<p>漏洞的成因在于shiro和Spring对于<code>;</code>的处理逻辑不一样：</p>
<ul>
<li>shiro会直接截断<code>;</code>号后面的部分</li>
<li>Spring会截断<code>;</code>号和其后第一个<code>/</code>的部分，然后剩余部分作拼接处理</li>
</ul>
<p>1.5.3版本的shiro修复如下：</p>
<figure data-type="image" tabindex="14"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210322142711.png" alt="image-20210322142710956" loading="lazy"></figure>
<p>shiro不再获取<code>ContextPath</code>并进行格式化处理，就无法利用<code>ContextPath</code>分号绕过了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro复盘--权限绕过（二）]]></title>
        <id>https://f4de-bak.github.io/post/pHD8v5hTZ/</id>
        <link href="https://f4de-bak.github.io/post/pHD8v5hTZ/">
        </link>
        <updated>2021-03-18T15:58:56.000Z</updated>
        <summary type="html"><![CDATA[<p>Shiro漏洞复盘系列--1.5.2版本以下的权限绕过复现分析。（CVE-2020-1957）</p>
]]></summary>
        <content type="html"><![CDATA[<p>Shiro漏洞复盘系列--1.5.2版本以下的权限绕过复现分析。（CVE-2020-1957）</p>
<!-- more -->
<h1 id="简介">简介</h1>
<p>漏洞影响范围：shiro &lt; 1.5.2</p>
<h1 id="配置">配置</h1>
<pre><code class="language-xml">        &lt;!-- shiro dependence --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;
            &lt;version&gt;1.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
            &lt;version&gt;1.4.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>shiro config同上一篇文章。</p>
<h1 id="分析">分析</h1>
<p>访问<code>/admin/</code>，已经无法绕过shiro过滤器的拦截：</p>
<figure data-type="image" tabindex="1"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318204849.png" alt="image-20210318204406613" loading="lazy"></figure>
<p>访问<code>/;/admin</code>，成功绕过shiro拦截：</p>
<figure data-type="image" tabindex="2"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318204845.png" alt="image-20210318204649795" loading="lazy"></figure>
<h2 id="shiro">shiro</h2>
<p>还是在<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>，打下断点，发送请求：</p>
<figure data-type="image" tabindex="3"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318205038.png" alt="image-20210318205038597" loading="lazy"></figure>
<p>主要在<code>getPathWithApplication</code>方法里：</p>
<figure data-type="image" tabindex="4"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318205119.png" alt="image-20210318205119386" loading="lazy"></figure>
<p>这里会获取到请求的<code>contextPath</code>和<code>requestUri</code>，获取到<code>uri</code>为<code>/;/admin</code>之后进入<code>decodeAndCleanUriString</code>方法中：</p>
<figure data-type="image" tabindex="5"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318205306.png" alt="image-20210318205306717" loading="lazy"></figure>
<p><code>decodeAndCleanUriString</code>方法中把请求的<code>uri</code>按分号进行截断：</p>
<figure data-type="image" tabindex="6"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318205340.png" alt="image-20210318205340398" loading="lazy"></figure>
<p><code>/;/admin</code>经过shiro的处理之后，我们请求的路由就变成了<code>/</code>，由于<code>/</code>路由下没有设置过滤器，所以就shiro的过滤器无法匹配，绕过了shiro的权限认证。</p>
<h2 id="spring">Spring</h2>
<p>依然在<code>org.springframework.web.util.UrlPathHelper#getLookupPathForRequest</code>方法中打下断点，发送请求开始调试：</p>
<figure data-type="image" tabindex="7"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319003838.png" alt="image-20210319003838013" loading="lazy"></figure>
<p>这次主要跟入<code>getPathWithinApplication</code>方法：</p>
<figure data-type="image" tabindex="8"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319003935.png" alt="image-20210319003935113" loading="lazy"></figure>
<p>再跟入<code>getRequestUri</code>方法：</p>
<figure data-type="image" tabindex="9"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319004024.png" alt="image-20210319004024544" loading="lazy"></figure>
<p>主要看<code>decodeAndCleanUriString</code>方法，这个方法中对请求的路由做了一些处理：</p>
<figure data-type="image" tabindex="10"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319004119.png" alt="image-20210319004119307" loading="lazy"></figure>
<p>跟入第一个方法<code>removeSemicolonContent</code>，经过这部分代码处理之后<code>/;/admin</code>变成了<code>//admin</code>：</p>
<figure data-type="image" tabindex="11"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319004437.png" alt="image-20210319004437224" loading="lazy"></figure>
<p>再跟入第三个方法<code>getSanitizedPath</code>，在获取到<code>//</code>的索引值之后，直接删除该索引上对应的字符，<code>//admin</code>也就变了<code>/admin</code>：</p>
<figure data-type="image" tabindex="12"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319004636.png" alt="image-20210319004636257" loading="lazy"></figure>
<p>最后也就返回了<code>/admin</code>的路由，之后就是正常匹配 <em>hanlderMethod</em> 的过程了，不再赘述：</p>
<figure data-type="image" tabindex="13"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319004921.png" alt="image-20210319004921899" loading="lazy"></figure>
<h1 id="修复">修复</h1>
<p>1.5.2版本的<code>org.aoache.shiro.web.util.WebUtils#getRequestUri</code>方法如下：</p>
<pre><code class="language-java">public static String getRequestUri(HttpServletRequest request) {
        String uri = (String)request.getAttribute(&quot;javax.servlet.include.request_uri&quot;);
        if (uri == null) {
            uri = valueOrEmpty(request.getContextPath()) + &quot;/&quot; + valueOrEmpty(request.getServletPath()) + valueOrEmpty(request.getPathInfo());
        }

        return normalize(decodeAndCleanUriString(request, uri));
    }
</code></pre>
<p>uri获取的规则变成了<code>ContextPath</code> 、<code>ServletPath</code>、<code>PathInfo</code>三者拼接而成：</p>
<figure data-type="image" tabindex="14"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210319092755.png" alt="image-20210319092755726" loading="lazy"></figure>
<p><code>getServletPath</code>方法可以正确处理分号，再经过后续方法处理，<code>/;/admin</code>就被正常处理为了<code>/admin</code>，之后就会被shiro的过滤器正常拦截。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shiro复盘--权限绕过（一）]]></title>
        <id>https://f4de-bak.github.io/post/0ZTfZW4mf/</id>
        <link href="https://f4de-bak.github.io/post/0ZTfZW4mf/">
        </link>
        <updated>2021-03-18T14:42:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Shiro漏洞复盘系列--1.5.0版本以下的权限绕过复现分析。（无CVE编号）</p>
]]></summary>
        <content type="html"><![CDATA[<p>Shiro漏洞复盘系列--1.5.0版本以下的权限绕过复现分析。（无CVE编号）</p>
<!-- more -->
<h1 id="简介">简介</h1>
<p>影响版本：shiro &lt; 1.50</p>
<h1 id="配置">配置</h1>
<p>依赖：</p>
<pre><code class="language-xml">        &lt;!-- shiro dependence --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;
            &lt;version&gt;1.4.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
            &lt;version&gt;1.4.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>shiro配置：</p>
<pre><code class="language-java">@Configuration
public class shiroConfig {
    @Bean
    Auth auth() {
        return new Auth();
    }

    @Bean
    SecurityManager securityManager() {
        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();
        manager.setRealm(auth());
        return manager;
    }

    @Bean
    ShiroFilterFactoryBean shiroFilterFactoryBean() {
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        bean.setSecurityManager(securityManager());
        // 配置认证权限
        bean.setLoginUrl(&quot;/login&quot;);
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;/login&quot;, &quot;anon&quot;);
        map.put(&quot;/user&quot;, &quot;anon&quot;);
        map.put(&quot;/admin&quot;, &quot;authc&quot;);
        bean.setFilterChainDefinitionMap(map);
        return bean;
    }
}
</code></pre>
<h1 id="分析">分析</h1>
<p>正常访问<code>/admin</code>路由，因为过滤器的配置，所以会302跳转到<code>/login</code>路由下：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210318111544.png" alt="image-20210318111544460" loading="lazy"></figure>
<p>在<code>/admin</code>路由后面加<code>/</code>，访问<code>/admin/</code>路由，发现可以绕过shiro的鉴权：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210318111607.png" alt="image-20210318111607786" loading="lazy"></figure>
<h2 id="shiro">shiro</h2>
<p>shiro处理URL从而进行匹配的方法为<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>，打下断点，发送请求：</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210318111949.png" alt="image-20210318111949903" loading="lazy"></figure>
<p>在获取到请求的URL之后，会进入到<code>pathMatches</code>方法中进行匹配：</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210318112142.png" alt="image-20210318112142653" loading="lazy"></figure>
<p>连续跟进到<code>doMatch</code>方法中：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210318112700.png" alt="image-20210318112700753" loading="lazy"></figure>
<pre><code class="language-java">return pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) : !path.endsWith(this.pathSeparator);
</code></pre>
<p>在这一行中，pattern为<code>/admin</code>，pathSeparator为<code>/</code>，path为<code>/admin/</code>，所以返回的<code>!path.endsWith(this.pathSeparator)</code>就为<code>false</code>，shiro就认为没有匹配到对应路由，绕过了shiro的权限验证。</p>
<h2 id="spring">Spring</h2>
<p>Spring处理URL的逻辑在<code>org.springframework.web.util.UrlPathHelper#getLookupPathForRequest</code>方法中：</p>
<pre><code class="language-java">    public String getLookupPathForRequest(HttpServletRequest request) {
        String pathWithinApp = this.getPathWithinApplication(request);
        if (!this.alwaysUseFullPath &amp;&amp; !this.skipServletPathDetermination(request)) {
            String rest = this.getPathWithinServletMapping(request, pathWithinApp);
            return StringUtils.hasLength(rest) ? rest : pathWithinApp;
        } else {
            return pathWithinApp;
        }
    }
</code></pre>
<p>获取到请求路径之后并返回到<code>getHandlerInternal</code>方法中，进入<code>lookupHandlerMethod</code>中寻找<em>HandlerMethod</em>：</p>
<figure data-type="image" tabindex="6"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318140402.png" alt="image-20210318140402323" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318140726.png" alt="image-20210318140726533" loading="lazy"></figure>
<p>跟进该方法，在获取到<code>mappingRegistry</code>之后会在map中尝试获取路由：</p>
<figure data-type="image" tabindex="8"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318141003.png" alt="image-20210318141003299" loading="lazy"></figure>
<p><code>this.pathLookup</code>中储存了我们配置的三个路由和另外一个<code>/error</code>路由，调用<code>get</code>方法尝试匹配我们的请求路径：</p>
<figure data-type="image" tabindex="9"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318141007.png" alt="image-20210318141007802" loading="lazy"></figure>
<p>获取的结果为<code>null</code>，之后会调用<code>addMatchingMappings</code>方法，便利<code>mappingRegistry</code>中的每一个map进行匹配：</p>
<figure data-type="image" tabindex="10"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318141531.png" alt="test" loading="lazy"></figure>
<p>主要匹配的逻辑是在<code>getMatchingMapping</code>方法中：</p>
<figure data-type="image" tabindex="11"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318141658.png" alt="image-20210318141657981" loading="lazy"></figure>
<p>接着跟进到<code>getMatchingCondition</code>方法中，再跟入<code>this.patternsCondition.getMatchingCondition(request)</code>：</p>
<figure data-type="image" tabindex="12"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318142216.png" alt="image-20210318142215935" loading="lazy"></figure>
<p>获取到<code>lookupPath</code>之后再跟入<code>getMatchingPatterns</code>方法：</p>
<figure data-type="image" tabindex="13"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318142438.png" alt="image-20210318142438109" loading="lazy"></figure>
<p>再跟入<code>getMatingPattern</code>方法：</p>
<figure data-type="image" tabindex="14"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318142539.png" alt="image-20210318142539119" loading="lazy"></figure>
<p>这个方法最后的返回值如下：</p>
<pre><code class="language-java">return this.useTrailingSlashMatch &amp;&amp; !pattern.endsWith(&quot;/&quot;) &amp;&amp; this.pathMatcher.match(pattern + &quot;/&quot;, lookupPath) ? pattern + &quot;/&quot; : null;
</code></pre>
<p>会在<code>pattern</code>（<code>/admin</code>）后加一个<code>/</code>：</p>
<figure data-type="image" tabindex="15"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318142810.png" alt="image-20210318142810475" loading="lazy"></figure>
<p>逐层返回，获取到对应的<code>hanlderMethod</code>，spring处的URL匹配成功：</p>
<figure data-type="image" tabindex="16"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318142956.png" alt="image-20210318142956771" loading="lazy"></figure>
<h1 id="修复">修复</h1>
<p>通过diff一下新版本的代码，可以发现shiro对于此漏洞的修复方案是<strong>对URL和匹配的pattern的末尾做了去<code>/</code>号的处理。</strong></p>
<figure data-type="image" tabindex="17"><img src="https://image-1302577725.cos.ap-beijing.myqcloud.com/img/20210318225201.png" alt="image-20210318225201723" loading="lazy"></figure>
<p>下篇文章将会复现分析 shiro &lt; 1.5.2 版本下的权限绕过问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat AJP协议漏洞复现]]></title>
        <id>https://f4de-bak.github.io/post/JB6ZNGMXX/</id>
        <link href="https://f4de-bak.github.io/post/JB6ZNGMXX/">
        </link>
        <updated>2021-03-16T02:52:47.000Z</updated>
        <summary type="html"><![CDATA[<p>CVE-2020-1938复现，漏洞利用难度不大，但是还是学到了很多新的东西。</p>
]]></summary>
        <content type="html"><![CDATA[<p>CVE-2020-1938复现，漏洞利用难度不大，但是还是学到了很多新的东西。</p>
<!-- more -->
<h1 id="简介">简介</h1>
<p>AJP协议是一种定向包协议，采用二进制形式代替文本形式，主要是为了提高性能和添加SSL的支持，在tomcat中使用的是AJP1.3，简称为ajp13。</p>
<p>在tomcat的配置文件<code>server.xml</code>中配置了两种连接方式：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315141928.png" alt="image-20210315141921787" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315141933.png" alt="image-20210315141933682" loading="lazy"></figure>
<p>一个是默认开放在8080端口的HTTP Connector，另一个则是默认开放在8009端口的AJP Connertor，而在tomcat中这个协议的监听一直是默认开启的。</p>
<p>tomcat可以通过AJP协议和另一个web容器进行交互通信，比如Apache。tomcat可以作为Servlet或者JSP的容器，但是在处理一些静态资源的速度却不如其他的HTTP服务器（如IIS、Apache）。所以实际应用中常常把tomcat和其他服务器进行集成，对于不支持Servlet、JSP的服务器，可以通过AJP协议把请求转发给tomcat，从而实现优势互补。</p>
<p>正常情况下用户使用客户端通过HTTP协议来和tomcat服务器进行通信，但是也可以通过AJP协议来和tomcat通信，这时候就会由AJP Connertor来处理AJP请求。<strong>显然浏览器不直接支持AJP协议，所以要想使用AJP协议，要么通过中间代理服务器进行转发，要么自己根据AJP协议的格式来实现一个客户端。</strong></p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315142847.jpeg" alt="解析Tomcat HTTP协议与AJP协议解析Tomcat HTTP协议与AJP协议" loading="lazy"></figure>
<p>但是Tomcat AJP协议存在安全漏洞（CVE-2020-1938），攻击者可以通过构造AJP协议请求中的特定属性值，来进行任意文件读取(一般为webapp/ROOT路径下)，同时如果AJP服务器存在文件上传接口，则还可能通过漏洞进行文件包含，实现远程代码执行。</p>
<p>漏洞影响范围：</p>
<ul>
<li>Tomcat 6.x</li>
<li>Tomcat 7.x &lt; 7.0.100</li>
<li>Tomcat 8.x &lt; 8.5.51</li>
<li>Tomcat 9.x &lt; 9.0.31</li>
</ul>
<h1 id="tomcat架构简单分析">Tomcat架构简单分析</h1>
<p>Tomcat架构分析：https://blog.csdn.net/xlgen157387/article/details/79006434</p>
<p>Tomcat Service主要包含两个部分：<strong>Connector</strong>和<strong>Container</strong>。</p>
<ul>
<li><em>Connector</em>主要用于处理连接，并提供socket和request及response直接的转化。</li>
<li><em>Container</em>用于封装和管理Servlet，处理具体的请求。</li>
</ul>
<p>在<em>Container</em>中有四个子容器：</p>
<ul>
<li><em>Engine</em>：引擎，用来管理多个站点，一个service最多只能有一个Engine。</li>
<li><em>Host</em>：代表一个站点，也叫虚拟主机，通过配置Host可以添加站点。</li>
<li><em>Context</em>：代表一个应用程序，对应一套程序，或者一个WEB-INF目录以及目录中的web.xml文件。</li>
<li><em>Wrapper</em>：每一个Wrapper封装着一个Servlet。</li>
</ul>
<p>以下面的tomcat文件目录做对照：</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315160205.png" alt="image-20210315160205337" loading="lazy"></figure>
<p><em>Webapps</em>目录代表一个Host，而其下的每个目录都对应着一个Context，其中ROOT目录存放着主应用，其他目录存放着子应用。当我们访问Context的时候，如果是ROOT目录下的，则可以直接通过<code>www.xxx.com/</code>来访问，而如果要访问其他子目录，则需要通过<code>www.xxx.com/docs</code>来访问。当然，主应用目录是可以修改的，默认情况下为ROOT目录。</p>
<p>Tomcat处理一个请求的流程大致如下：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315145747.png" alt="image-20201013113437489" loading="lazy"></figure>
<ol>
<li>在获取到TCP/IP数据包的时候，会交给Processor将解析，并封装成我们熟悉的request和response对象，然后传递给下一步处理。</li>
<li>Engine来进行Host、Context、Mapping中Servlet的匹配。</li>
<li>Servlet中调用方法（service、doGet、doPost······）来进行处理，并返回结果。</li>
</ol>
<h1 id="ajp数据包处理">AJP数据包处理</h1>
<p>对于HTTP请求和AJP请求的数据包，在封装成request和response对象之后的流程并无差别，主要区别就是对socket流量处理和Processor解析的过程不同。</p>
<p><code>org.apache.coyote.Processor</code>接口提供了这些功能，对于不同的协议，有不同的接口实现类。负责处理AJP请求的实现类为<code>AjpProcessor</code>：</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315161900.png" alt="image-20210315161900016" loading="lazy"></figure>
<p>在<code>AjpProcessor</code>的<code>service()</code>方法中调用了<code>prepareRequest()</code>方法进行数据预处理：</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316105726.png" alt="image-20210315162453835" loading="lazy"></figure>
<p>而之后会调用Adapter来将请求交给Container来处理：</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315162639.png" alt="image-20210315162639014" loading="lazy"></figure>
<p>AJP协议中的漏洞，就出现在<code>prepareRequest()</code>方法中。</p>
<h1 id="漏洞复现">漏洞复现</h1>
<p>poc：https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</p>
<h2 id="环境搭建">环境搭建</h2>
<p>在环境搭建这里我还是踩了一点小坑，先说一些我本地的环境：</p>
<ul>
<li>Windows10 专业版</li>
<li>JDK 8u281</li>
<li>IDEA专业版 2020.3.2</li>
</ul>
<p>以下是我搭建出正常复现环境的步骤：</p>
<ol>
<li>
<p>github上下载存在漏洞的Tomcat版本：https://github.com/apache/tomcat/archive/9.0.19.zip</p>
</li>
<li>
<p>解压，在文件目录中添加pom.xml，改为maven方式构建项目，其中pom.xml文件内容如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat&lt;/artifactId&gt;
    &lt;name&gt;tomcat&lt;/name&gt;
    &lt;version&gt;9.0.19&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.ant&lt;/groupId&gt;
            &lt;artifactId&gt;ant&lt;/artifactId&gt;
            &lt;version&gt;1.10.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
            &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
            &lt;version&gt;1.6.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
            &lt;artifactId&gt;geronimo-jaxrpc_1.1_spec&lt;/artifactId&gt;
            &lt;version&gt;2.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.jdt&lt;/groupId&gt;
            &lt;artifactId&gt;ecj&lt;/artifactId&gt;
            &lt;version&gt;3.17.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.easymock&lt;/groupId&gt;
            &lt;artifactId&gt;easymock&lt;/artifactId&gt;
            &lt;version&gt;4.0.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
</li>
<li>
<p>在根目录里新建<code>home</code>文件夹，把<code>webapps</code>和<code>conf</code>文件夹放入<code>home</code>文件夹中：</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316001210.png" alt="image-20210316001203592" loading="lazy"></figure>
</li>
<li>
<p>在IDEA中导入项目，选择我们新建的pom.xml文件：</p>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316001439.png" alt="image-20210316001439225" loading="lazy"></figure>
</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316001506.png" alt="image-20210316001506159" loading="lazy"></figure>
<ol start="5">
<li>
<p>导入项目之后，将<code>java</code>文件夹标记为<code>Sources Root</code>，把<code>test</code>文件夹标记为<code>Test Sources Root</code>：</p>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316001733.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>把 <code>home/webapps/examples/WEB-INF/classes/trailers</code> 目录拷贝到 <code>test</code> 目录下：</p>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316001838.png" alt="image-20210316001838650" loading="lazy"></figure>
</li>
<li>
<p>把 <code>home/webapps/examples/WEB-INF/classes/util/CookieFilter.java</code> 文件拷贝到 <code>test/util</code> 目录下：</p>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316001919.png" alt="image-20210316001919101" loading="lazy"></figure>
</li>
<li>
<p>找到 <code>BootStrap</code>类的<code>main</code>方法，运行，这时候应该会出现下面错误：</p>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316002035.png" alt="image-20210316002035809" loading="lazy"></figure>
</li>
<li>
<p>添加VM参数：<code>-Dcatalina.home={你的项目路径}\home</code>：</p>
<figure data-type="image" tabindex="16"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316002211.png" alt="image-20210316002211736" loading="lazy"></figure>
</li>
<li>
<p>在<code>org.apache.catalina.startup.ContextConfig</code>类中的<code>configureStart</code>方法中添加<code>context.addServletContainerInitializer(new JasperInitializer(), null);</code>，用于初始化JSP解析器：</p>
<figure data-type="image" tabindex="17"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316002433.png" alt="image-20210316002433890" loading="lazy"></figure>
</li>
<li>
<p>删除 <code>home/webapps/examples</code> 文件夹，然后运行 <code>main</code> 方法，访问<code>127.0.0.1:8080</code>：</p>
<figure data-type="image" tabindex="18"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316002617.png" alt="image-20210316002617780" loading="lazy"></figure>
</li>
<li>
<p>同时可以看到8009端口已经开放：</p>
</li>
</ol>
<figure data-type="image" tabindex="19"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315144452.png" alt="image-20210315144452701" loading="lazy"></figure>
<h2 id="文件读取">文件读取</h2>
<p>在<code>AjpProcessor#prepareRequest</code>方法打上断点，调试启动tomcat，并使用POC来发送ajp请求：</p>
<figure data-type="image" tabindex="20"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315163242.png" alt="image-20210315163241922" loading="lazy"></figure>
<p>在699行出进行了数据包头部信息的读取，当头设置为<code>SC_A_REQ_ATTRIBUTE</code>的时候，则会读取出n和v：</p>
<figure data-type="image" tabindex="21"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315163647.png" alt="image-20210315163647369" loading="lazy"></figure>
<p>然后当n不为<code>SC_A_REQ_LOCAL_ADDR</code>、<code>SC_A_REQ_REMOTE_PORT</code>、<code>SC_A_SSL_PROTOCOL</code>的时候，会用v来对n进行赋值：</p>
<figure data-type="image" tabindex="22"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315163728.png" alt="image-20210315163728511" loading="lazy"></figure>
<p>POC中发送的数据包一共会读取三次：</p>
<pre><code>n = javax.servlet.include.request_uri	v = /

n = javax.servlet.include.path_info		v = WEB-INF/web.xml

n = javax.servlet.include.servlet_path	v = /
</code></pre>
<p>对应POC中的这一部分代码：</p>
<figure data-type="image" tabindex="23"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315164145.png" alt="image-20210315164145601" loading="lazy"></figure>
<p>之后进入<code>getAdapter().service()</code>方法中，这里可以看到我们请求的URL为<code>/asdf</code>：</p>
<figure data-type="image" tabindex="24"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315164452.png" alt="image-20210315164452905" loading="lazy"></figure>
<p><code>/asdf</code>这个路由是我们故意构造的一个不存在的路由，当路由无法匹配对应的servlet的时候会由<code>org.apache.catalina.servlets.DefaultServlet</code>来处理请求，是在<code>{CATALINA_HOME}/conf/web.xml</code>中默认配置的：</p>
<figure data-type="image" tabindex="25"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210315164813.png" alt="image-20210315164813262" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316004730.png" alt="image-20210316004730879" loading="lazy"></figure>
<p>在<code>DefaultServlet</code>的<code>service()</code>方法中打下断点，当我们请求方式为<code>GET</code>方式的时候，存在<code>service()-&gt;doGet()-&gt;serveResource()</code>的调用链：</p>
<figure data-type="image" tabindex="27"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316003333.png" alt="image-20210316003333899" loading="lazy"></figure>
<p>再贴一个调用栈：</p>
<figure data-type="image" tabindex="28"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316003409.png" alt="image-20210316003409095" loading="lazy"></figure>
<p>在<code>serveResource()</code>中调用了<code>getRelativePath()</code>方法：</p>
<figure data-type="image" tabindex="29"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316003649.png" alt="image-20210316003649513" loading="lazy"></figure>
<p>在这个方法中会读取出我们POC中构造的恶意属性，然后把两个属性拼接成一个path：</p>
<figure data-type="image" tabindex="30"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316003825.png" alt="image-20210316003824993" loading="lazy"></figure>
<p>然后在<code>serveResource()</code>方法中会把这个path传入<code>resources.getResource()</code>方法中造成任意文件读取：</p>
<figure data-type="image" tabindex="31"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316003942.png" alt="image-20210316003942820" loading="lazy"></figure>
<p>之后会把根据path获取到文件资源序列化输出，这样客户端再根据AJP协议的数据包进行解包，就能读取到文件内容了：</p>
<figure data-type="image" tabindex="32"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316004240.png" alt="image-20210316004240365" loading="lazy"></figure>
<h2 id="jsp文件包含">JSP文件包含</h2>
<p>Tomcat会将以<code>.jsp、.jspx</code>结尾的url交给<code>org.apache.jasper.servlet.JspServlet</code>来处理：</p>
<figure data-type="image" tabindex="33"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316010505.png" alt="image-20210316010505803" loading="lazy"></figure>
<figure data-type="image" tabindex="34"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316010516.png" alt="image-20210316010516564" loading="lazy"></figure>
<p>所以我们可以修改POC中的请求路径：</p>
<figure data-type="image" tabindex="35"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316011052.png" alt="image-20210316011052683" loading="lazy"></figure>
<p>然后再<code>JspServlet#service</code>方法中打下断点：</p>
<figure data-type="image" tabindex="36"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316012336.png" alt="image-20210316012336568" loading="lazy"></figure>
<p>这里同样会获取<code>INCLUDE_SERVLET_PATH</code>和<code>INCLUDE_PATH_INFO</code>两个属性，而这两个属性是可通过构造AJP请求数据包来控制的，这两个属性拼接到<code>jspUri</code>之后，会进入到<code>serviceJsp</code>方法：</p>
<figure data-type="image" tabindex="37"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316012711.png" alt="image-20210316012711652" loading="lazy"></figure>
<p>这个方法会把<code>jspUri</code>（上述为<code>/WEB-INF/testfile</code>）所表示的文件解析为JSP文件，从而形成文件包含：</p>
<figure data-type="image" tabindex="38"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316013019.png" alt="image-20210316013019379" loading="lazy"></figure>
<p>值得注意的是，这个所包含的文件和我们请求的url（<code>/asdf/f4de.jsp</code>）是没有关系的。</p>
<h1 id="其他">其他</h1>
<h2 id="读取其他context">读取其他Context</h2>
<p>默认情况下是读取的主目录（ROOT目录）中的文件内容，此外还可以读取其他Context中文件的内容，只需要修改一下请求的url即可（文件包含同理）：</p>
<figure data-type="image" tabindex="39"><img src="https://i.loli.net/2021/03/16/4zv5V8bDfcwEPTL.png" alt="image-20210316102141936" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316104937.png" alt="image-20210316102213823" loading="lazy"></figure>
<h2 id="目录穿越可读性">目录穿越可读性</h2>
<p>我们尝试穿越出webapps这个目录，读取其他文件夹中的内容：</p>
<p><code>DefaultServlet#serveResource</code>打下断点，在<code>resources.getResource</code>方法中：</p>
<figure data-type="image" tabindex="41"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316104946.png" alt="image-20210316103039869" loading="lazy"></figure>
<figure data-type="image" tabindex="42"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316105005.png" alt="image-20210316103129512" loading="lazy"></figure>
<p>跟进<code>RequestUtil.normalize</code>：</p>
<figure data-type="image" tabindex="43"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316105018.png" alt="image-20210316103339267" loading="lazy"></figure>
<p>只要包含<code>/../</code>，就会返回<code>null</code>，直接抛出异常：</p>
<figure data-type="image" tabindex="44"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210316105027.png" alt="image-20210316103512792" loading="lazy"></figure>
<h1 id="修复">修复</h1>
<ul>
<li>
<p>升级Tomcat版本</p>
</li>
<li>
<p>禁用AJP协议（删除或注释conf/server.xml中对应的内容）</p>
</li>
<li>
<p>为AJP Connector配置secret，或为AJP设置协议认证凭证</p>
<pre><code class="language-xml">&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot; secret=&quot;YOUR_TOMCAT_AJP_SECRET&quot;/&gt;

&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot;requiredSecret=&quot;YOUR_TOMCAT_AJP_SECRET&quot; /&gt;
</code></pre>
</li>
</ul>
<h1 id="参考">参考</h1>
<p>[攻击Java Web应用 - <a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open">Java Web安全] (zhishihezi.net)</a></p>
<p><a href="https://l3yx.github.io/2020/03/26/Tomcat-Ajp%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/#IDEA%E8%B0%83%E8%AF%95Tomcat">Tomcat Ajp协议漏洞 | l3yx's blog</a></p>
<p><a href="https://www.cnblogs.com/jhxxb/p/10768580.html">IDEA 导入 Tomcat9 源码 - 江湖小小白 - 博客园 (cnblogs.com)</a></p>
<p>https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</p>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/79006434">四张图带你了解Tomcat系统架构--让面试官颤抖的Tomcat回答系列！_徐刘根的博客-CSDN博客</a></p>
<p><a href="https://e.xieyonghui.com/apache-tomcat-ajp-leak-at-2020-02-21_196.html">apache tomcat AJP漏洞修复方案(2020-02-21) - Exception List (xieyonghui.com)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Javassist学习]]></title>
        <id>https://f4de-bak.github.io/post/UkRuYBIYv/</id>
        <link href="https://f4de-bak.github.io/post/UkRuYBIYv/">
        </link>
        <updated>2021-03-10T12:45:54.000Z</updated>
        <summary type="html"><![CDATA[<p>关于 Javassist 的学习笔记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>关于 Javassist 的学习笔记。</p>
<!-- more -->
<h1 id="start">start</h1>
<p><em><strong>javassist</strong></em> 是一个分析、编辑、创建Java字节码的类库，与 <em><strong>ASM</strong></em> 相比提供了更加方便的API，无需再去关注底层的栈操作和字节码。</p>
<p>依赖导入：</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
            &lt;version&gt;3.27.0-GA&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h1 id="api">API</h1>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassPool</td>
<td>ClassPool是一个存储CtClass的容器，如果调用<code>get</code>方法会搜索并创建一个表示该类的CtClass对象</td>
</tr>
<tr>
<td>CtClass</td>
<td>CtClass表示的是从ClassPool获取的类对象，可对该类就行读写编辑等操作</td>
</tr>
<tr>
<td>CtMethod</td>
<td>可读写的类方法对象</td>
</tr>
<tr>
<td>CtConstructor</td>
<td>可读写的类构造方法对象</td>
</tr>
<tr>
<td>CtField</td>
<td>可读写的类成员变量对象</td>
</tr>
</tbody>
</table>
<p><em><strong>javassist</strong></em> 提供的API和反射非常类似，基本可以对应反射中的<code>Class</code>、<code>Method</code>、<code>Constructor</code>、<code>Field</code>。</p>
<p>此外 <em><strong>javassist</strong></em> 还提供了一些内置的标识符来表示一些特定的含义：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0, $1, $2, ...</code></td>
<td><code>this</code>和方法参数</td>
</tr>
<tr>
<td><code>$args</code></td>
<td><code>Object[]</code>类型的参数数组</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>所有的参数，如<code>m($$)</code>等价于<code>m($1,$2,...)</code></td>
</tr>
<tr>
<td><code>$cflow(...)</code></td>
<td>cflow变量</td>
</tr>
<tr>
<td><code>$r</code></td>
<td>返回类型，用于类型转换</td>
</tr>
<tr>
<td><code>$w</code></td>
<td>包装类型，用于类型转换</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>方法返回值</td>
</tr>
<tr>
<td><code>$sig</code></td>
<td>方法签名，返回<code>java.lang.Class[]</code>数组类型</td>
</tr>
<tr>
<td><code>$type</code></td>
<td>返回值类型，<code>java.lang.Class</code>类型</td>
</tr>
<tr>
<td><code>$class</code></td>
<td>当前类，<code>java.lang.Class</code>类型</td>
</tr>
</tbody>
</table>
<h1 id="usage">usage</h1>
<p>相比于基于访问者模式的 <em><strong>ASM</strong></em> 框架来说，使用 <em><strong>javassist</strong></em> 来操作字节码是非常简单的。</p>
<h2 id="读取类-方法-成员变量信息">读取类、方法、成员变量信息</h2>
<p>通过 <code>ClassPool</code> 来获取 <code>CtClass</code>对象之后，基本就和反射一样来读取类的信息。</p>
<pre><code class="language-java">package src;

public class TestClass {
    private String name;

    public TestClass() {
    }

    public TestClass(String name) {
        this.name = name;
    }

    public String getId() {
        return name;
    }

    public void setId(String name) {
        this.name = name;
    }

    public void hello() {
        System.out.println(&quot;Hello &quot; + this.name);
    }
}
</code></pre>
<pre><code class="language-java">package src;


import javassist.*;

import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws Exception {
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = classPool.getCtClass(TestClass.class.getName());
        // 获取成员变量
        CtField[] fields = ctClass.getDeclaredFields();
        // 获取方法
        CtMethod[] methods = ctClass.getDeclaredMethods();
        // 获取构造方法
        CtConstructor[] constructors = ctClass.getDeclaredConstructors();
        // 输出信息
        System.out.println(&quot;------fields------&quot;);
        Arrays.stream(fields).forEach(System.out::println);
        System.out.println(&quot;------methods------&quot;);
        Arrays.stream(methods).forEach(System.out::println);
        System.out.println(&quot;------constructors------&quot;);
        Arrays.stream(constructors).forEach(System.out::println);
    }
}
</code></pre>
<pre><code class="language-java">// output

------fields------
src.TestClass.name:Ljava/lang/String;
------methods------
javassist.CtMethod@fb809fd2[public getId ()Ljava/lang/String;]
javassist.CtMethod@db3679d4[public setId (Ljava/lang/String;)V]
javassist.CtMethod@30063153[public hello ()V]
------constructors------
javassist.CtConstructor@46d56d67[public TestClass ()V]
javassist.CtConstructor@d8355a8[public TestClass (Ljava/lang/String;)V]
</code></pre>
<h2 id="修改类的方法">修改类的方法</h2>
<p>通过调用 <code>CtMethods</code> 的一些方法就可以进行方法逻辑的修改：</p>
<ul>
<li><em><strong>setModifiers</strong></em>：修改方法的修饰符</li>
<li><em><strong>insertBefore</strong></em>：在方法执行前插入代码</li>
<li><em><strong>insertAfter</strong></em>：方法执行后插入代码</li>
<li><em><strong>setBody</strong></em>：修改整段方法的代码</li>
<li>······</li>
</ul>
<pre><code class="language-java">package src;


import javassist.*;

import java.io.File;
import java.io.FileOutputStream;

public class Main {
    public static void main(String[] args) throws Exception {
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = classPool.getCtClass(TestClass.class.getName());
        // 获取 hello 方法
        CtMethod hello = ctClass.getDeclaredMethod(&quot;hello&quot;, null);
        // 修改方法的修饰符
        hello.setModifiers(Modifier.PRIVATE);
        // 实现简单AOP
        hello.insertBefore(&quot;System.out.println(\&quot;func start\&quot;);&quot;);
        hello.insertAfter(&quot;System.out.println(\&quot;func over\&quot;);&quot;);
        // 写入class文件
        byte[] bytecode = ctClass.toBytecode();
        File file = new File(&quot;target/classes/src/TestClass.class&quot;);
        FileOutputStream fos = new FileOutputStream(file);
        fos.write(bytecode);
        fos.flush();
        fos.close();
    }
}
</code></pre>
<p>修改后的字节码：</p>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package src;

public class TestClass {
    private String name;

    public TestClass() {
    }

    public TestClass(String name) {
        this.name = name;
    }

    public String getId() {
        return this.name;
    }

    public void setId(String name) {
        this.name = name;
    }

    private void hello() {
        System.out.println(&quot;func start&quot;);
        System.out.println(&quot;Hello &quot; + this.name);
        Object var2 = null;
        System.out.println(&quot;func over&quot;);
    }
}
</code></pre>
<p>修改成员变量信息方法上大体差不多。</p>
<h2 id="动态生成类">动态生成类</h2>
<p>使用<code>CtClass</code>的<code>makeClass</code>方法就可以动态生成一个类。</p>
<pre><code class="language-java">package src;


import javassist.*;

import java.io.File;
import java.io.FileOutputStream;

public class Main {
    public static void main(String[] args) {
        ClassPool classPool = ClassPool.getDefault();
        CtClass ctClass = classPool.makeClass(&quot;src.ClassMade&quot;);
        try {
            // 加入静态代码块
            ctClass.makeClassInitializer().insertBefore(&quot;java.lang.System.out.println(\&quot;static code block\&quot;);&quot;);

            // 创建成员变量
            CtField id = CtField.make(&quot;private static int id = 3;&quot;, ctClass);
            ctClass.addField(id);

            // 创建方法
            CtMethod main = CtMethod.make(
                    &quot;public static void main(String[] args) {java.lang.System.out.println(id);}&quot;,
                    ctClass
            );
            ctClass.addMethod(main);

            // 写入class文件
            byte[] bytecode = ctClass.toBytecode();
            File file = new File(&quot;target/classes/src/ClassMade.class&quot;);
            if (!(file.exists())) {
                file.createNewFile();
            }
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(bytecode);
            fos.flush();
            fos.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>如果要使用这个类的话，需要向 <em><strong>JVM</strong></em> 中动态注册，这个就是类加载中的内容了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java字节码文件结构]]></title>
        <id>https://f4de-bak.github.io/post/java-zi-jie-ma-wen-jian-jie-gou/</id>
        <link href="https://f4de-bak.github.io/post/java-zi-jie-ma-wen-jian-jie-gou/">
        </link>
        <updated>2021-03-04T08:57:34.000Z</updated>
        <summary type="html"><![CDATA[<p>一篇关于Java字节码文件结构的学习笔记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一篇关于Java字节码文件结构的学习笔记。</p>
<!-- more -->
<p><a href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7.2">Chapter 4. The class File Format (oracle.com)</a></p>
<p>Java的字节码文件格式规定如下：</p>
<pre><code class="language-java">ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
</code></pre>
<p>Class文件由<strong>无符号数</strong>和<strong>表</strong>组成：</p>
<ul>
<li>在JVM的的规范中，u1、u2、u4分别表示1、2、4字节的无符号数</li>
<li>表是由多个无符号数或者其他表作为数据项的复杂数据类型，都习惯以<code>_info</code>结尾</li>
</ul>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190510170421396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5NjM5NDg=,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"></figure>
</blockquote>
<p>下面以这个class文件为例：</p>
<pre><code class="language-java">interface TestInterface {
    void hello();
}

public class TestClass implements TestInterface {
    private int id;

    public TestClass() {
        this.id = 3;
    }

    @Override
    public void hello() {
        System.out.println(&quot;Hello&quot; + id);
    }
}
</code></pre>
<h1 id="magic">Magic</h1>
<p>Magic（魔数）是class文件的标识，其有固定值 <code>0xCAFEBABE</code>  ，JVM加载class文件的时候会先加载4字节的数据（ <code>u4 magic</code> ）来判断该文件是不是字节码文件。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302203849.png" alt="image-20210302203842019" loading="lazy"></figure>
<h1 id="minormajor_version">minor/major_version</h1>
<p><code>minor_version</code>和<code>major_version</code>两部分组成了class文件的版本号，两者分别表示副版本号和主版本号，我们常说的Java1.8、Java11表示的就是主版本号，下表是版本号的对应关系：</p>
<table>
<thead>
<tr>
<th>JDK版本</th>
<th><strong>十进制</strong></th>
<th><strong>十六进制</strong></th>
<th>发布时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK1.1</td>
<td>45</td>
<td>2D</td>
<td>1996-05</td>
</tr>
<tr>
<td>JDK1.2</td>
<td>46</td>
<td>2E</td>
<td>1998-12</td>
</tr>
<tr>
<td>JDK1.3</td>
<td>47</td>
<td>2F</td>
<td>2000-05</td>
</tr>
<tr>
<td>JDK1.4</td>
<td>48</td>
<td>30</td>
<td>2002-02</td>
</tr>
<tr>
<td>JDK1.5</td>
<td>49</td>
<td>31</td>
<td>2004-09</td>
</tr>
<tr>
<td>JDK1.6</td>
<td>50</td>
<td>32</td>
<td>2006-12</td>
</tr>
<tr>
<td>JDK1.7</td>
<td>51</td>
<td>33</td>
<td>2011-07</td>
</tr>
<tr>
<td>JDK1.8</td>
<td>52</td>
<td>34</td>
<td>2014-03</td>
</tr>
<tr>
<td>Java9</td>
<td>53</td>
<td>35</td>
<td>2017-09</td>
</tr>
<tr>
<td>Java10</td>
<td>54</td>
<td>36</td>
<td>2018-03</td>
</tr>
<tr>
<td>Java11</td>
<td>55</td>
<td>37</td>
<td>2018-09</td>
</tr>
<tr>
<td>Java12</td>
<td>56</td>
<td>38</td>
<td>2019-03</td>
</tr>
<tr>
<td>Java13</td>
<td>57</td>
<td>39</td>
<td>2019-09</td>
</tr>
<tr>
<td>Java14</td>
<td>58</td>
<td>3A</td>
<td>2020-03</td>
</tr>
<tr>
<td>Java15</td>
<td>59</td>
<td>3B</td>
<td>2020-09</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302203933.png" alt="image-20210302203933815" loading="lazy"></figure>
<h1 id="constant_pool_count">constant_pool_count</h1>
<p>常量池计数器 <code>u2 constant_pool_count</code>）表示的是常量池中的数量，其值为<code>常量池中的数量 + 1</code>，<strong>需要特别注意的是<code>long</code>和<code>double</code>类型的常量池对象占两个常量位，并且常量池计数是从1开始的。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302204056.png" alt="image-20210302204056277" loading="lazy"></figure>
<p>0X0036也就是54，表示常量池中有53个元素。</p>
<h1 id="constant_pool">constant_pool</h1>
<p>常量池（constant_pool），<code>cp_info constant_pool[constant_pool_count-1]</code>是一种表结构，<code>cp_info</code>表示的是常量池对象。</p>
<p>常量池中主要存放<strong>字面量</strong>和<strong>符号引用</strong>：</p>
<ul>
<li><strong>字面量</strong>：文本字符串、被声明为<code>final</code>的常量</li>
<li><strong>符号引用</strong>：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>
</ul>
<p>常量池中的每一个元素都是一个表，表的类型共有<strong>14种</strong>，它们都具有一个共同的特点：<strong>表开始的部分都是一个<code>u1</code>的标志位。</strong></p>
<blockquote>
<p>下图为常量池中14中数据类型的总表：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210304165259.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210304165254.png" alt="img" loading="lazy"></figure>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302211926.png" alt="image-20210302211918990" style="zoom: 80%;" />
<p>常量池中第一个一个常量的标志为<code>0A</code>，也就是10，表示该常量为<code>CONSTANT_Methodref_info</code>，为<strong>类中方法的符号引用</strong>，按照上表，可以读出<strong>指向方法的类描述符</strong>的索引位置为<code>0x0007</code>，<strong>指向名称及类型描述符</strong>的索引位置为<code>0x0015</code>······</p>
<p>使用<strong>jclasslib</strong>插件可以快速查看常量池中的常量信息：</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302212753.png" alt="image-20210302212752980" loading="lazy"></figure>
<h1 id="access_flags">access_flags</h1>
<p>访问标志（<code>u2 access_flags</code>）用于识别一些<strong>类</strong>或者<strong>接口</strong>层次的访问信息。</p>
<table>
<thead>
<tr>
<th>标志名</th>
<th>十六进制值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>声明为public</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>声明为final</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>废弃/仅JDK1.0.2前使用，1.0.2之后都为真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>声明为接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>声明为abstract</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>声明为synthetic，表示该class文件并非由Java源代码所生成</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识注解类型</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识枚举类型</td>
</tr>
</tbody>
</table>
<p>对于例子<code>TestClass</code>来说，它的标志应该是<code>ACC_PUBLIC</code>和<code>ACC_SUPER</code>，所以<code>access_flags</code>的值为<code>0x0001 | 0x0020 = 0x0021</code>。</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302214110.png" alt="image-20210302214109941" loading="lazy"></figure>
<h1 id="this_class">this_class</h1>
<p><code>u2 this_class</code>表示的是当前类在常量池中的索引位置（<code>CONSTANT_Class_info</code>）。</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302214614.png" alt="image-20210302214614561" loading="lazy"></figure>
<h1 id="super_class">super_class</h1>
<p><code>u2 super_class</code>表示的是当前类的父类在常量池中的索引位置。</p>
<h1 id="interfaces_count">interfaces_count</h1>
<p><code>u2 interfaces_count</code>表示当前类实现的接口数量。</p>
<h1 id="interfacesinterfaces_count">interfaces[interfaces_count]</h1>
<p><code>u2 interfaces[interfaces_count]</code>表示所有接口在常量池中的索引位置。</p>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302215302.png" alt="image-20210302215302711" loading="lazy"></figure>
<h1 id="fields_count">fields_count</h1>
<p><code>u2 fields_count</code>表示类中成员变量的数量。</p>
<h1 id="fieldsfields_count">fields[fields_count]</h1>
<p><code>field_info fields[fields_count]</code>是成员变量表（字段表）信息，字段表的结构如下：</p>
<pre><code class="language-java">field_info {
   u2 access_flags; //成员变量访问标志
   u2 name_index; //成员变量名称在常量池中的索引
   u2 descriptor_index; //成员变量的描述符在常量池中的索引
   u2 attributes_count; //成员变量属性数量
   attribute_info attributes[attributes_count]; //成员变量的属性信息
}
</code></pre>
<blockquote>
<p>成员变量访问标志表：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>volatile，不可和ACC_FIANL一起使用</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>在序列化中被忽略的字段</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>由编译器产生，不存在于源代码中</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>enum</td>
</tr>
</tbody>
</table>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302220419.png" alt="image-20210302220418964" loading="lazy"></figure>
<ul>
<li>0x0002表示字段的访问标志为<code>ACC_PRIVATE</code></li>
<li>0x0009表示变量名称在常量池中的索引位置为9</li>
<li>0x000A表示变量描述符在常量池中的索引位置为10</li>
<li>0x0000表示属性数量为0</li>
</ul>
<h1 id="methods_count">methods_count</h1>
<p><code>u2 methods_count</code>表示类的方法数量。</p>
<h1 id="methodsmethods_count">methods[methods_count]</h1>
<p><code>method_info methods[methods_count]</code>是方法表，结构和字段表是一样的。</p>
<pre><code class="language-java">method_info {
   u2 access_flags; //方法访问标志
   u2 name_index; //方法名称在常量池中的索引
   u2 descriptor_index; //方法的描述符在常量池中的索引
   u2 attributes_count; //方法属性数量
   attribute_info attributes[attributes_count]; //方法的属性信息
}
</code></pre>
<p><code>attribute_info attributes[attributes_count]</code>是一个很复杂的存储结构，存储着各种属性信息：</p>
<pre><code class="language-java">attribute_info {
   u2 attribute_name_index; //属性名称在常量池中的索引
   u4 attribute_length; //属性长度
   u1 info[attribute_length]; //属性信息，不同属性的结构不同
}
</code></pre>
<p>值得注意的是，方法代码逻辑是放在<code>code</code>属性中的，是以<strong>Java虚拟机指令</strong>的形式存储的。</p>
<blockquote>
<p>code属性的结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>属性名称索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>局部变量表所需的存储空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>字节码长度</td>
</tr>
<tr>
<td>u1</td>
<td>code[code_length]</td>
<td>存储字节码指令的一系列字节流</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td></td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes[attributes_count]</td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302223659.png" alt="image-20210302223659435" loading="lazy"></figure>
<p>接着来分析<code>code</code>属性：</p>
<ul>
<li>000D：code属性在常量池中的索引为13</li>
<li>0000 003C：属性长度为60字节</li>
<li>0002：max_stack为2</li>
<li>0001：max_locals为1</li>
<li>0000 000A：code_length为10，表示还有10个字节来存储指令</li>
<li>2AB7 0001 2A06 B500 02B1：<strong>存储JVM指令的字节流</strong></li>
<li>0000：没有异常抛出</li>
<li>0002：表示<code>code</code>属性还有2个属性</li>
</ul>
<p><code>code</code>属性中主要包含的属性为：<code>LineNumberTable</code>和<code>LocalVariableTable</code>。</p>
<p><code>LineNumberTable</code>的结构如下：</p>
<pre><code class="language-java">LineNumberTable_attribute {
    u2 attribute_name_index;        //属性名称索引
    u4 attribute_length;            //属性长度
    u2 line_number_table_length;
    {   u2 start_pc;            //字节码行号
        u2 line_number;         //java源码行号
    } line_number_table[line_number_table_length];
}
</code></pre>
<ul>
<li>
<p>000E：属性索引位置在常量池中的索引位置为14</p>
</li>
<li>
<p>0000 000E：属性长度为14个字节</p>
</li>
<li>
<p>0003：line_number_table_length为3</p>
</li>
<li>
<p>0000 000A：前两个字节表示字节码行号，后两个字节表示对应的Java代码行号</p>
</li>
<li>
<p>······</p>
</li>
</ul>
<p>具体属性结构可以参考：<a href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7.13">Chapter 4. The class File Format (oracle.com)</a></p>
<h1 id="attributes_count">attributes_count</h1>
<p><code>u2 attributes_count</code>表示当前class文件的属性表的元素个数。</p>
<h1 id="attributesattributes_count">attributes[attributes_count]</h1>
<blockquote>
<p>Java15中的属性表：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>章节</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConstantValue Attribute</td>
<td>§4.7.2</td>
</tr>
<tr>
<td>Code Attribute</td>
<td>§4.7.3</td>
</tr>
<tr>
<td>StackMapTable Attribute</td>
<td>§4.7.4</td>
</tr>
<tr>
<td>Exceptions Attribute</td>
<td>§4.7.5</td>
</tr>
<tr>
<td>InnerClasses Attribute</td>
<td>§4.7.6</td>
</tr>
<tr>
<td>EnclosingMethod Attribute</td>
<td>§4.7.7</td>
</tr>
<tr>
<td>Synthetic Attribute</td>
<td>§4.7.8</td>
</tr>
<tr>
<td>Signature Attribute</td>
<td>§4.7.9</td>
</tr>
<tr>
<td>SourceFile Attribute</td>
<td>§4.7.10</td>
</tr>
<tr>
<td>SourceDebugExtension Attribute</td>
<td>§4.7.11</td>
</tr>
<tr>
<td>LineNumberTable Attribute</td>
<td>§4.7.12</td>
</tr>
<tr>
<td>LocalVariableTable Attribute</td>
<td>§4.7.13</td>
</tr>
<tr>
<td>LocalVariableTypeTable Attribute</td>
<td>§4.7.14</td>
</tr>
<tr>
<td>Deprecated Attribute</td>
<td>§4.7.15</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations Attribute</td>
<td>§4.7.16</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations Attribute</td>
<td>§4.7.17</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotations Attribute</td>
<td>§4.7.18</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotations Attribute</td>
<td>§4.7.19</td>
</tr>
<tr>
<td>RuntimeVisibleTypeAnnotations Attribute</td>
<td>§4.7.20</td>
</tr>
<tr>
<td>RuntimeInvisibleTypeAnnotations Attribute</td>
<td>§4.7.21</td>
</tr>
<tr>
<td>AnnotationDefault Attribute</td>
<td>§4.7.22</td>
</tr>
<tr>
<td>BootstrapMethods Attribute</td>
<td>§4.7.23</td>
</tr>
<tr>
<td>MethodParameters Attribute</td>
<td>§4.7.24</td>
</tr>
<tr>
<td>Module Attribute</td>
<td>§4.7.25</td>
</tr>
<tr>
<td>ModulePackages Attribute</td>
<td>§4.7.26</td>
</tr>
<tr>
<td>ModuleMainClass Attribute</td>
<td>§4.7.27</td>
</tr>
<tr>
<td>NestHost Attribute</td>
<td>§4.7.28</td>
</tr>
<tr>
<td>NestMembers Attribute</td>
<td>§4.7.29</td>
</tr>
</tbody>
</table>
</blockquote>
<p>属性表是动态的，每一种属性都有自己独有的数据结构，在读取到属性名称之后还要根据属性的不同类型来解析不同属性表中的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java8的新特性-Stream]]></title>
        <id>https://f4de-bak.github.io/post/java8-de-xin-te-xing-stream/</id>
        <link href="https://f4de-bak.github.io/post/java8-de-xin-te-xing-stream/">
        </link>
        <updated>2021-02-25T07:44:07.000Z</updated>
        <summary type="html"><![CDATA[<p>流（stream）是Java8中的一个重要特性，利用匿名函数和流可以极大简化一些繁琐的操作。</p>
]]></summary>
        <content type="html"><![CDATA[<p>流（stream）是Java8中的一个重要特性，利用匿名函数和流可以极大简化一些繁琐的操作。</p>
<!-- more -->
<h2 id="lambda-function">Lambda Function</h2>
<h3 id="一般形式">一般形式</h3>
<p>lambda的一般形式，由两部分组成：</p>
<pre><code class="language-java">(par1, par2···) -&gt; {
    // code block
    return xxx；
}

</code></pre>
<p><code>(par1, par2···)</code>表示参数，类型可以省略，因为编译器可以自动推断出参数类型，<code>{···}</code>中间的内容表示方法体，就是要执行的代码。</p>
<p>如果方法体中只有一行<code>return xxx</code>的代码，那么完全可以更加简洁：</p>
<pre><code>(par1, par2···) -&gt; xxx;

</code></pre>
<p>比如下面的例子：</p>
<pre><code>(s1, s2) -&gt; {
    return s1.equals(s2);
}

// 等同于

(s1, s2) -&gt; s1.equals(s2);

</code></pre>
<p>函数返回值的类型也是由编译器自动判断的。</p>
<h3 id="functionalinterface">FunctionalInterface</h3>
<p>由于lambda创建了一个匿名函数，我们可以把这个函数交给一个变量，然后利用这个变量去执行我们写好的函数，比如在python中，我们可以这样做：</p>
<pre><code>In [1]: func = lambda x : x+2

In [2]: print(func(1))
3

</code></pre>
<p>但由于Java是强类型语言，在基本类型和引用类型中没有一个用来表示“这个变量是一个函数”的类型，但是Java8为我们提供一种<code>函数接口</code>，一个lambda表达式可以赋值给一个函数接口的对象，然后利用这个对象去调用lambda表达式。</p>
<p>我们可以使用注解<code>@FunctionalInterface</code>来定义一个函数接口，比如这样：</p>
<pre><code class="language-java">@FunctionalInterface
interface LambdaFunc {
    boolean strCompare(String s1, String s2);
}

public class Demo1 {
    public static void main(String[] args) {
        LambdaFunc test = (s1, s2) -&gt; s1.equals(s2);

        System.out.println(test.strCompare(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p>一个函数接口具有一下特点：</p>
<ol>
<li>函数接口是单（抽象）方法接口</li>
<li>接口中抽象方法的返回值就是我们所写的lambda表达式中函数体的返回值</li>
<li>接口中抽象方法的参数就是我们所写的lambda表达式中的参数</li>
<li>只有显式调用<code>函数接口对象.抽象方法</code>并传入相应的参数才会调用对应的lambda表达式</li>
</ol>
<p>其实有些函数接口我们没有必要自己实现，Java8中的<code>java.util.function</code>包中给我们提供了很多的函数接口，比如下面这样：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        BiPredicate&lt;String, String&gt; function = (String s1, String s2) -&gt; s1.equals(s2);

        System.out.println(function.test(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p><code>BiPredicate</code>就是一个<code>function</code>包中内置的一个函数接口，它的抽象方法会接受两个参数，并且返回布尔值：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210104112204.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210104112204.png" loading="lazy"></figure>
<h3 id="方法引用">方法引用</h3>
<p>上面的例子还可以进一步化简：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        BiPredicate&lt;String, String&gt; function = String::equals;

        System.out.println(function.test(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p>我们把<code>(String s1, String s2) -&gt; s1.equals(s2)</code>简化成了<code>String::equals</code>，这种简化方式称作方法引用，所谓方法引用，就是某个方法的签名和接口的抽象方法签名恰好一致，那么就可以直接把方法引用作为lambda表达式传入接口。</p>
<pre><code>s -&gt; System.out.println(s)  &lt;==&gt;  System.out::println

</code></pre>
<h2 id="stream">Stream</h2>
<p><a href="https://www.youtube.com/watch?v=t1-YZ6bF-g0">Java 8 STREAMS Tutorial - YouTube</a></p>
<h3 id="steam介绍">Steam介绍</h3>
<blockquote>
<p>Stream（流）是Java8中引入的全新API</p>
</blockquote>
<p>Steam本身并不会保存数据，而是类似于一个比较高级的迭代器，数据源中的元素单向传递到流中，不可以往复，只能遍历一次，就像水流一样一去不复返。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175021.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175021.png" loading="lazy"></figure>
<p>在图中涉及到了两个名词：<em>Intermediate operations</em>和<em>Ternimal operations</em>，这是流中的两个重要操作。</p>
<p>Stream分为中间操作(Intermediate operations)和终端操作(Ternimal operations)：</p>
<ul>
<li>中间操作用于对流进行过滤、转换、排序等，比如<code>filter</code>、<code>map</code>、<code>sort</code>，多个中间操作可以被串联起来，一个流经过中间操作之后还是一个流。</li>
<li>终端操作用于将流转换为其他Java对象，比如<code>forEach</code>、<code>collect</code>、<code>reduce</code>等。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175251.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175251.png" loading="lazy"></figure>
<p>一个流中可以有零个或者多个中间操作，对于比较大的数据集：我们应该遵循的一个原则是先使用<code>filter</code>将其过滤，然后再使用其他的中间操作比如<code>map</code>、<code>sort</code>等。</p>
<p>一个流只能有一个终端操作，一些常用的终端操作作用如下：</p>
<ul>
<li><code>forEach</code>：对于对于每个流中的元素使用相同的函数</li>
<li><code>collect</code>：将流中的元素汇总到一个集合里</li>
<li>······</li>
</ul>
<p>在使用stream的时候，基本会遵循下面三个步骤：</p>
<ol>
<li>创建stream</li>
<li>进行流的转换，返回一个新的stream对象（链式操作）</li>
<li>将流转换为其他Java对象</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175912.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175912.png" loading="lazy"></figure>
<p>一个流可以通过<code>Collections</code>、<code>Lists</code>、<code>Sets</code>、<code>ints</code>、<code>longs</code>、<code>doubles</code>、<code>arrays</code>、<code>lines of file</code>创建出来。</p>
<h3 id="intermediate-operation">Intermediate operation</h3>
<p>intermediate ooperation（中间操作）：一个流后面可以串联一个或多个中间操作。中间操作可以打开流，对流中的数据进行过滤、映射等，并返回一个新的流供之后操作实用。</p>
<h4 id="map">map</h4>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(1, 2, 3, 4, 5, 6).map(x -&gt; x + 2).forEach(System.out::println);

    }
}

/*
3
4
5
6
7
8

Process finished with exit code 0
*/

</code></pre>
<p>中间操作<code>map</code>用于将一个对象转换为另一个对象，它的签名要求实现一个<code>Function</code>函数接口：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106122927.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106122927.png" loading="lazy"></figure>
<p>这个函数接口的静态方法是接受一个T类型的参数，然后返回一个R类型的对象：</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123014.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123014.png" loading="lazy"></figure>
<p>对于上面的例子，我们做的操作就是把X + 2，所以T和R都是<code>Integer</code>。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(1, 2, 3, 4, 5, 6).map(String::valueOf).forEach(s -&gt; System.out.println(s.getClass().getName()));

    }
}

/*
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String

Process finished with exit code 0

</code></pre>
<p>对于这个例子来说，T就是<code>Integer</code>，R就是<code>String</code>。</p>
<h4 id="filter">filter</h4>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;AI&quot;, &quot;Ankit&quot;, &quot;Kushal&quot;, &quot;Bob&quot;, &quot;Susan&quot;, &quot;Hans&quot;).filter(s -&gt; s.startsWith(&quot;A&quot;)).forEach(System.out::println);

    }
}

/*
AI
Ankit

Process finished with exit code 0

</code></pre>
<p><code>filter</code>是一个过滤器，可以通过给定的条件把流中不符合条件的元素剔除掉，它的签名要求我们实现一个<code>Predicate</code>函数接口，这个函数接口的静态方法接收一个T类型的参数，而返回一个布尔值：</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123958.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123958.png" loading="lazy"></figure>
<p>下一个例子，通过map将流中的每个元素首字母转换为小写，然后再用filter过滤出符合条件的元素：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;AI&quot;, &quot;Ankit&quot;, &quot;Kushal&quot;, &quot;Bob&quot;, &quot;Susan&quot;, &quot;Hans&quot;).map(String::toLowerCase).filter(s -&gt; s.startsWith(&quot;a&quot;)).forEach(System.out::println);

    }
}

/*
ai
ankit

Process finished with exit code 0

</code></pre>
<h4 id="distinct">distinct</h4>
<p>对于流中的元素进行去重，不需要先把其转换为<code>Set</code>，只需要实用<code>distinct</code>中间操作即可：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5, 1);
        list.stream().distinct().forEach(System.out::println);

    }
}

/*
1
2
3
4
5

</code></pre>
<h3 id="ternimal-operations">Ternimal operations</h3>
<p>Ternimal operations（终端操作）：终端操作是流的链式调用的最后一步，被终端操作处理过的流就会变成其他的Java对象。在一个流的链式调用流程中，终端操作只会被调用一次，调用之后流就会关闭。</p>
<h4 id="foreach">forEach</h4>
<p><code>forEach</code>是最常用的一个终端操作，它的参数是一个<code>Consumer</code>函数接口（一元），对流中的每一个元素执行相同的操作，最常见的就是打印流中的每个元素：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        Stream.of(1, 2, 3, 4, 5).map(x -&gt; x + 1).forEach(System.out::println);
    }
}

/*
2
3
4
5
6

</code></pre>
<h4 id="reduce">reduce</h4>
<p>reduce（聚合）操作可以通过聚合函数把流中的元素聚合成一个结果。</p>
<p>reduce方法传入的是一个<code>BinaryOperator</code>接口对象，它的<code>apply</code>方法是一个二元抽象方法，会把传入的两个参数进行运算，并返回运算的结果：</p>
<pre><code class="language-java">T apply(T t, T u);

</code></pre>
<p>下面的代码实用了聚合操作来进行求和：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Integer integer = Stream.of(1, 2, 3, 4, 5).reduce(0, (sum, i) -&gt; sum + i);
        System.out.println(&quot;integer = &quot; + integer);

    }
}

/*
integer = 15

</code></pre>
<p>这样似乎不是很好理解，可以使用for循环来改写一下上面的代码：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) throws Exception {
        int[] arrays = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int i : arrays) {
            System.out.printf(&quot;sum = sum + i = %d + %d\n&quot;, sum, i);
            sum += i;
        }
        System.out.println(sum);
    }

</code></pre>
<p>值得注意的是，我们上面的代码在reduce方法中传入一个初始值0，这样一来，在第一轮中，0就会被作为函数<code>(sum, i) -&gt; sum + i</code>中sum的初始值，而i的初始值就是Stream中的第一个元素<code>1</code>，执行完第一轮的结果为<code>0 + 1 = 1</code>，而这个结果又会作为第二轮中<code>sum</code>的初始值，<code>i</code>的值为Stream中的第二个元素<code>2</code>，如此达到了累加的效果。</p>
<pre><code>sum = sum + i = 0 + 1 = 1
sum = sum + i = 1 + 2 = 3
sum = sum + i = 3 + 3 = 6
sum = sum + i = 6 + 4 = 10
sum = sum + i = 10 + 5 = 15
15

</code></pre>
<p>此外，reduce方法还可以不传入初始值，这样一来，第一轮中的<code>sum</code>的初始值就变为了Stream中的第一个元素<code>1</code>，<code>i</code>的初始值就变成了Stream中的第二个元素<code>2</code>；reduce操作返回的结果也变成了<code>Optional&lt;Integer&gt;</code>对象，需要多调用一个get方法才能得到运算的结果。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) throws Exception {
        Optional&lt;Integer&gt; integer = Stream.of(1, 2, 3, 4, 5).reduce((sum, i) -&gt; sum + i);
        System.out.println(&quot;integer = &quot; + integer.get());
    }
}

/*
integer = 15

</code></pre>
<pre><code class="language-java">sum = sum + i = 1 + 2 = 3
sum = sum + i = 3 + 3 = 6
sum = sum + i = 6 + 4 = 10
sum = sum + i = 10 + 5 = 15
15

</code></pre>
<p>灵活使用reduce，可以达到一些神奇的效果，比如把配置文件中的<code>key=value</code>这种形式的字符串作为键值对储存在Map中：</p>
<pre><code class="language-java">public class Demo2 {
    public static void main(String[] args) {
        List&lt;String&gt; props = List.of(&quot;profile=native&quot;, &quot;debug=true&quot;, &quot;logging=warn&quot;, &quot;interval=500&quot;);
        Map&lt;String, String&gt; propMap = props.stream().map(line -&gt; {
            String[] split = line.split(&quot;=&quot;);
            return Map.of(split[0], split[1]);
        }).reduce(new HashMap&lt;String, String&gt;(), (map, kvmap) -&gt; {
            System.out.println(kvmap.toString() + &quot; -&gt; HashMap&quot;);
            map.putAll(kvmap);
            return map;
        });

        propMap.forEach((key, value) -&gt; {
            System.out.println(key + &quot;: &quot; + value);
        });
    }
}

</code></pre>
<pre><code class="language-java">{profile=native} -&gt; HashMap
{debug=true} -&gt; HashMap
{logging=warn} -&gt; HashMap
{interval=500} -&gt; HashMap
logging: warn
interval: 500
debug: true
profile: native

</code></pre>
<h3 id="other-features">Other features</h3>
<p>Stream具有延时性：只有当终端操作存在的时候，中间的操作才会被执行。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        
        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;).filter(s -&gt; {
            System.out.println(&quot;filter: &quot; + s);
            return true;
        });

    }
}

// 不打印结果

public class Demo1 {
    public static void main(String[] args) {
        
        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;).filter(s -&gt; {
            System.out.println(&quot;filter: &quot; + s);
            return true;
        }).forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));

    }
}

/*
filter: a1
forEach: a1
filter: a2
forEach: a2
filter: a3
forEach: a3
filter: a4
forEach: a4

Process finished with exit code 0
*/

</code></pre>
<p>这样设计是出于性能的考虑，Stream垂直执行可以减少对每个元素的操作个数</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;).map(x -&gt; {
            System.out.println(&quot;map: &quot; + x);
            return x.toUpperCase();
        }).anyMatch(x -&gt; {
            System.out.println(&quot;anyMatch: &quot; + x);
            return x.startsWith(&quot;B&quot;);
        });

    }
}

/*
map: a1
anyMatch: A1
map: b1
anyMatch: B1
*/

</code></pre>
<p><code>anyMatch()</code>方法是一个聚合操作，和中间操作<code>filter()</code>类似，可以传入一个返回值为布尔类型的lambda表达式，当表达式返回值为True的时候就结束循环。</p>
<p>Stream是不能复用的，当调用聚合操作之后流就关闭了，此时如果再调用流则会抛出异常。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream&lt;String&gt; stream = Stream.of(&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;).map(x -&gt; {
            System.out.println(&quot;map: &quot; + x);
            return x.toUpperCase();
        });
        stream.anyMatch(s -&gt; {
            System.out.println(&quot;Stream close&quot;);
            return true;
        });
        stream.filter(s -&gt; true);

    }
}

/*
map: a1
Stream close
Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed
  at java.util.stream.AbstractPipeline.&lt;init&gt;(AbstractPipeline.java:203)
  at java.util.stream.ReferencePipeline.&lt;init&gt;(ReferencePipeline.java:94)
  at java.util.stream.ReferencePipeline$StatelessOp.&lt;init&gt;(ReferencePipeline.java:618)
  at java.util.stream.ReferencePipeline$2.&lt;init&gt;(ReferencePipeline.java:163)
  at java.util.stream.ReferencePipeline.filter(ReferencePipeline.java:162)
  at steam.Demo1.main(Demo1.java:18)
*/

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客重建]]></title>
        <id>https://f4de-bak.github.io/post/bo-ke-chong-jian/</id>
        <link href="https://f4de-bak.github.io/post/bo-ke-chong-jian/">
        </link>
        <updated>2021-02-24T13:08:28.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.f4de.ink/">原博客</a>的本地文件在格硬盘的时候误删，索性直接重建一个。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.f4de.ink/">原博客</a>的本地文件在格硬盘的时候误删，索性直接重建一个。</p>
<!-- more -->
<p>2021，新的起点✨。</p>
]]></content>
    </entry>
</feed>