<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://f4de-bak.github.io</id>
    <title>F4DE的博客</title>
    <updated>2021-03-06T16:34:02.247Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://f4de-bak.github.io"/>
    <link rel="self" href="https://f4de-bak.github.io/atom.xml"/>
    <subtitle>Keep fantasy</subtitle>
    <logo>https://f4de-bak.github.io/images/avatar.png</logo>
    <icon>https://f4de-bak.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, F4DE的博客</rights>
    <entry>
        <title type="html"><![CDATA[Java字节码文件结构]]></title>
        <id>https://f4de-bak.github.io/post/java-zi-jie-ma-wen-jian-jie-gou/</id>
        <link href="https://f4de-bak.github.io/post/java-zi-jie-ma-wen-jian-jie-gou/">
        </link>
        <updated>2021-03-04T08:57:34.000Z</updated>
        <summary type="html"><![CDATA[<p>一篇关于Java字节码文件结构的学习笔记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一篇关于Java字节码文件结构的学习笔记。</p>
<!-- more -->
<p><a href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7.2">Chapter 4. The class File Format (oracle.com)</a></p>
<p>Java的字节码文件格式规定如下：</p>
<pre><code class="language-java">ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
</code></pre>
<p>Class文件由<strong>无符号数</strong>和<strong>表</strong>组成：</p>
<ul>
<li>在JVM的的规范中，u1、u2、u4分别表示1、2、4字节的无符号数</li>
<li>表是由多个无符号数或者其他表作为数据项的复杂数据类型，都习惯以<code>_info</code>结尾</li>
</ul>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190510170421396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5NjM5NDg=,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"></figure>
</blockquote>
<p>下面以这个class文件为例：</p>
<pre><code class="language-java">interface TestInterface {
    void hello();
}

public class TestClass implements TestInterface {
    private int id;

    public TestClass() {
        this.id = 3;
    }

    @Override
    public void hello() {
        System.out.println(&quot;Hello&quot; + id);
    }
}
</code></pre>
<h1 id="magic">Magic</h1>
<p>Magic（魔数）是class文件的标识，其有固定值 <code>0xCAFEBABE</code>  ，JVM加载class文件的时候会先加载4字节的数据（ <code>u4 magic</code> ）来判断该文件是不是字节码文件。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302203849.png" alt="image-20210302203842019" loading="lazy"></figure>
<h1 id="minormajor_version">minor/major_version</h1>
<p><code>minor_version</code>和<code>major_version</code>两部分组成了class文件的版本号，两者分别表示副版本号和主版本号，我们常说的Java1.8、Java11表示的就是主版本号，下表是版本号的对应关系：</p>
<table>
<thead>
<tr>
<th>JDK版本</th>
<th><strong>十进制</strong></th>
<th><strong>十六进制</strong></th>
<th>发布时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK1.1</td>
<td>45</td>
<td>2D</td>
<td>1996-05</td>
</tr>
<tr>
<td>JDK1.2</td>
<td>46</td>
<td>2E</td>
<td>1998-12</td>
</tr>
<tr>
<td>JDK1.3</td>
<td>47</td>
<td>2F</td>
<td>2000-05</td>
</tr>
<tr>
<td>JDK1.4</td>
<td>48</td>
<td>30</td>
<td>2002-02</td>
</tr>
<tr>
<td>JDK1.5</td>
<td>49</td>
<td>31</td>
<td>2004-09</td>
</tr>
<tr>
<td>JDK1.6</td>
<td>50</td>
<td>32</td>
<td>2006-12</td>
</tr>
<tr>
<td>JDK1.7</td>
<td>51</td>
<td>33</td>
<td>2011-07</td>
</tr>
<tr>
<td>JDK1.8</td>
<td>52</td>
<td>34</td>
<td>2014-03</td>
</tr>
<tr>
<td>Java9</td>
<td>53</td>
<td>35</td>
<td>2017-09</td>
</tr>
<tr>
<td>Java10</td>
<td>54</td>
<td>36</td>
<td>2018-03</td>
</tr>
<tr>
<td>Java11</td>
<td>55</td>
<td>37</td>
<td>2018-09</td>
</tr>
<tr>
<td>Java12</td>
<td>56</td>
<td>38</td>
<td>2019-03</td>
</tr>
<tr>
<td>Java13</td>
<td>57</td>
<td>39</td>
<td>2019-09</td>
</tr>
<tr>
<td>Java14</td>
<td>58</td>
<td>3A</td>
<td>2020-03</td>
</tr>
<tr>
<td>Java15</td>
<td>59</td>
<td>3B</td>
<td>2020-09</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302203933.png" alt="image-20210302203933815" loading="lazy"></figure>
<h1 id="constant_pool_count">constant_pool_count</h1>
<p>常量池计数器 <code>u2 constant_pool_count</code>）表示的是常量池中的数量，其值为<code>常量池中的数量 + 1</code>，<strong>需要特别注意的是<code>long</code>和<code>double</code>类型的常量池对象占两个常量位，并且常量池计数是从1开始的。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302204056.png" alt="image-20210302204056277" loading="lazy"></figure>
<p>0X0036也就是54，表示常量池中有53个元素。</p>
<h1 id="constant_pool">constant_pool</h1>
<p>常量池（constant_pool），<code>cp_info constant_pool[constant_pool_count-1]</code>是一种表结构，<code>cp_info</code>表示的是常量池对象。</p>
<p>常量池中主要存放<strong>字面量</strong>和<strong>符号引用</strong>：</p>
<ul>
<li><strong>字面量</strong>：文本字符串、被声明为<code>final</code>的常量</li>
<li><strong>符号引用</strong>：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>
</ul>
<p>常量池中的每一个元素都是一个表，表的类型共有<strong>14种</strong>，它们都具有一个共同的特点：<strong>表开始的部分都是一个<code>u1</code>的标志位。</strong></p>
<blockquote>
<p>下图为常量池中14中数据类型的总表：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210304165259.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210304165254.png" alt="img" loading="lazy"></figure>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302211926.png" alt="image-20210302211918990" style="zoom: 80%;" />
<p>常量池中第一个一个常量的标志为<code>0A</code>，也就是10，表示该常量为<code>CONSTANT_Methodref_info</code>，为<strong>类中方法的符号引用</strong>，按照上表，可以读出<strong>指向方法的类描述符</strong>的索引位置为<code>0x0007</code>，<strong>指向名称及类型描述符</strong>的索引位置为<code>0x0015</code>······</p>
<p>使用<strong>jclasslib</strong>插件可以快速查看常量池中的常量信息：</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302212753.png" alt="image-20210302212752980" loading="lazy"></figure>
<h1 id="access_flags">access_flags</h1>
<p>访问标志（<code>u2 access_flags</code>）用于识别一些<strong>类</strong>或者<strong>接口</strong>层次的访问信息。</p>
<table>
<thead>
<tr>
<th>标志名</th>
<th>十六进制值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>声明为public</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>声明为final</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>废弃/仅JDK1.0.2前使用，1.0.2之后都为真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>声明为接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>声明为abstract</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>声明为synthetic，表示该class文件并非由Java源代码所生成</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识注解类型</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识枚举类型</td>
</tr>
</tbody>
</table>
<p>对于例子<code>TestClass</code>来说，它的标志应该是<code>ACC_PUBLIC</code>和<code>ACC_SUPER</code>，所以<code>access_flags</code>的值为<code>0x0001 | 0x0020 = 0x0021</code>。</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302214110.png" alt="image-20210302214109941" loading="lazy"></figure>
<h1 id="this_class">this_class</h1>
<p><code>u2 this_class</code>表示的是当前类在常量池中的索引位置（<code>CONSTANT_Class_info</code>）。</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302214614.png" alt="image-20210302214614561" loading="lazy"></figure>
<h1 id="super_class">super_class</h1>
<p><code>u2 super_class</code>表示的是当前类的父类在常量池中的索引位置。</p>
<h1 id="interfaces_count">interfaces_count</h1>
<p><code>u2 interfaces_count</code>表示当前类实现的接口数量。</p>
<h1 id="interfacesinterfaces_count">interfaces[interfaces_count]</h1>
<p><code>u2 interfaces[interfaces_count]</code>表示所有接口在常量池中的索引位置。</p>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302215302.png" alt="image-20210302215302711" loading="lazy"></figure>
<h1 id="fields_count">fields_count</h1>
<p><code>u2 fields_count</code>表示类中成员变量的数量。</p>
<h1 id="fieldsfields_count">fields[fields_count]</h1>
<p><code>field_info fields[fields_count]</code>是成员变量表（字段表）信息，字段表的结构如下：</p>
<pre><code class="language-java">field_info {
   u2 access_flags; //成员变量访问标志
   u2 name_index; //成员变量名称在常量池中的索引
   u2 descriptor_index; //成员变量的描述符在常量池中的索引
   u2 attributes_count; //成员变量属性数量
   attribute_info attributes[attributes_count]; //成员变量的属性信息
}
</code></pre>
<blockquote>
<p>成员变量访问标志表：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>volatile，不可和ACC_FIANL一起使用</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>在序列化中被忽略的字段</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>由编译器产生，不存在于源代码中</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>enum</td>
</tr>
</tbody>
</table>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302220419.png" alt="image-20210302220418964" loading="lazy"></figure>
<ul>
<li>0x0002表示字段的访问标志为<code>ACC_PRIVATE</code></li>
<li>0x0009表示变量名称在常量池中的索引位置为9</li>
<li>0x000A表示变量描述符在常量池中的索引位置为10</li>
<li>0x0000表示属性数量为0</li>
</ul>
<h1 id="methods_count">methods_count</h1>
<p><code>u2 methods_count</code>表示类的方法数量。</p>
<h1 id="methodsmethods_count">methods[methods_count]</h1>
<p><code>method_info methods[methods_count]</code>是方法表，结构和字段表是一样的。</p>
<pre><code class="language-java">method_info {
   u2 access_flags; //方法访问标志
   u2 name_index; //方法名称在常量池中的索引
   u2 descriptor_index; //方法的描述符在常量池中的索引
   u2 attributes_count; //方法属性数量
   attribute_info attributes[attributes_count]; //方法的属性信息
}
</code></pre>
<p><code>attribute_info attributes[attributes_count]</code>是一个很复杂的存储结构，存储着各种属性信息：</p>
<pre><code class="language-java">attribute_info {
   u2 attribute_name_index; //属性名称在常量池中的索引
   u4 attribute_length; //属性长度
   u1 info[attribute_length]; //属性信息，不同属性的结构不同
}
</code></pre>
<p>值得注意的是，方法代码逻辑是放在<code>code</code>属性中的，是以<strong>Java虚拟机指令</strong>的形式存储的。</p>
<blockquote>
<p>code属性的结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>属性名称索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>局部变量表所需的存储空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>字节码长度</td>
</tr>
<tr>
<td>u1</td>
<td>code[code_length]</td>
<td>存储字节码指令的一系列字节流</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td></td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes[attributes_count]</td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/f4de-bak/picture/picture20210302223659.png" alt="image-20210302223659435" loading="lazy"></figure>
<p>接着来分析<code>code</code>属性：</p>
<ul>
<li>000D：code属性在常量池中的索引为13</li>
<li>0000 003C：属性长度为60字节</li>
<li>0002：max_stack为2</li>
<li>0001：max_locals为1</li>
<li>0000 000A：code_length为10，表示还有10个字节来存储指令</li>
<li>2AB7 0001 2A06 B500 02B1：<strong>存储JVM指令的字节流</strong></li>
<li>0000：没有异常抛出</li>
<li>0002：表示<code>code</code>属性还有2个属性</li>
</ul>
<p><code>code</code>属性中主要包含的属性为：<code>LineNumberTable</code>和<code>LocalVariableTable</code>。</p>
<p><code>LineNumberTable</code>的结构如下：</p>
<pre><code class="language-java">LineNumberTable_attribute {
    u2 attribute_name_index;        //属性名称索引
    u4 attribute_length;            //属性长度
    u2 line_number_table_length;
    {   u2 start_pc;            //字节码行号
        u2 line_number;         //java源码行号
    } line_number_table[line_number_table_length];
}
</code></pre>
<ul>
<li>
<p>000E：属性索引位置在常量池中的索引位置为14</p>
</li>
<li>
<p>0000 000E：属性长度为14个字节</p>
</li>
<li>
<p>0003：line_number_table_length为3</p>
</li>
<li>
<p>0000 000A：前两个字节表示字节码行号，后两个字节表示对应的Java代码行号</p>
</li>
<li>
<p>······</p>
</li>
</ul>
<p>具体属性结构可以参考：<a href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7.13">Chapter 4. The class File Format (oracle.com)</a></p>
<h1 id="attributes_count">attributes_count</h1>
<p><code>u2 attributes_count</code>表示当前class文件的属性表的元素个数。</p>
<h1 id="attributesattributes_count">attributes[attributes_count]</h1>
<blockquote>
<p>Java15中的属性表：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>章节</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConstantValue Attribute</td>
<td>§4.7.2</td>
</tr>
<tr>
<td>Code Attribute</td>
<td>§4.7.3</td>
</tr>
<tr>
<td>StackMapTable Attribute</td>
<td>§4.7.4</td>
</tr>
<tr>
<td>Exceptions Attribute</td>
<td>§4.7.5</td>
</tr>
<tr>
<td>InnerClasses Attribute</td>
<td>§4.7.6</td>
</tr>
<tr>
<td>EnclosingMethod Attribute</td>
<td>§4.7.7</td>
</tr>
<tr>
<td>Synthetic Attribute</td>
<td>§4.7.8</td>
</tr>
<tr>
<td>Signature Attribute</td>
<td>§4.7.9</td>
</tr>
<tr>
<td>SourceFile Attribute</td>
<td>§4.7.10</td>
</tr>
<tr>
<td>SourceDebugExtension Attribute</td>
<td>§4.7.11</td>
</tr>
<tr>
<td>LineNumberTable Attribute</td>
<td>§4.7.12</td>
</tr>
<tr>
<td>LocalVariableTable Attribute</td>
<td>§4.7.13</td>
</tr>
<tr>
<td>LocalVariableTypeTable Attribute</td>
<td>§4.7.14</td>
</tr>
<tr>
<td>Deprecated Attribute</td>
<td>§4.7.15</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations Attribute</td>
<td>§4.7.16</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations Attribute</td>
<td>§4.7.17</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotations Attribute</td>
<td>§4.7.18</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotations Attribute</td>
<td>§4.7.19</td>
</tr>
<tr>
<td>RuntimeVisibleTypeAnnotations Attribute</td>
<td>§4.7.20</td>
</tr>
<tr>
<td>RuntimeInvisibleTypeAnnotations Attribute</td>
<td>§4.7.21</td>
</tr>
<tr>
<td>AnnotationDefault Attribute</td>
<td>§4.7.22</td>
</tr>
<tr>
<td>BootstrapMethods Attribute</td>
<td>§4.7.23</td>
</tr>
<tr>
<td>MethodParameters Attribute</td>
<td>§4.7.24</td>
</tr>
<tr>
<td>Module Attribute</td>
<td>§4.7.25</td>
</tr>
<tr>
<td>ModulePackages Attribute</td>
<td>§4.7.26</td>
</tr>
<tr>
<td>ModuleMainClass Attribute</td>
<td>§4.7.27</td>
</tr>
<tr>
<td>NestHost Attribute</td>
<td>§4.7.28</td>
</tr>
<tr>
<td>NestMembers Attribute</td>
<td>§4.7.29</td>
</tr>
</tbody>
</table>
</blockquote>
<p>属性表是动态的，每一种属性都有自己独有的数据结构，在读取到属性名称之后还要根据属性的不同类型来解析不同属性表中的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java8的新特性-Stream]]></title>
        <id>https://f4de-bak.github.io/post/java8-de-xin-te-xing-stream/</id>
        <link href="https://f4de-bak.github.io/post/java8-de-xin-te-xing-stream/">
        </link>
        <updated>2021-02-25T07:44:07.000Z</updated>
        <summary type="html"><![CDATA[<p>流（stream）是Java8中的一个重要特性，利用匿名函数和流可以极大简化一些繁琐的操作。</p>
]]></summary>
        <content type="html"><![CDATA[<p>流（stream）是Java8中的一个重要特性，利用匿名函数和流可以极大简化一些繁琐的操作。</p>
<!-- more -->
<h2 id="lambda-function">Lambda Function</h2>
<h3 id="一般形式">一般形式</h3>
<p>lambda的一般形式，由两部分组成：</p>
<pre><code class="language-java">(par1, par2···) -&gt; {
    // code block
    return xxx；
}

</code></pre>
<p><code>(par1, par2···)</code>表示参数，类型可以省略，因为编译器可以自动推断出参数类型，<code>{···}</code>中间的内容表示方法体，就是要执行的代码。</p>
<p>如果方法体中只有一行<code>return xxx</code>的代码，那么完全可以更加简洁：</p>
<pre><code>(par1, par2···) -&gt; xxx;

</code></pre>
<p>比如下面的例子：</p>
<pre><code>(s1, s2) -&gt; {
    return s1.equals(s2);
}

// 等同于

(s1, s2) -&gt; s1.equals(s2);

</code></pre>
<p>函数返回值的类型也是由编译器自动判断的。</p>
<h3 id="functionalinterface">FunctionalInterface</h3>
<p>由于lambda创建了一个匿名函数，我们可以把这个函数交给一个变量，然后利用这个变量去执行我们写好的函数，比如在python中，我们可以这样做：</p>
<pre><code>In [1]: func = lambda x : x+2

In [2]: print(func(1))
3

</code></pre>
<p>但由于Java是强类型语言，在基本类型和引用类型中没有一个用来表示“这个变量是一个函数”的类型，但是Java8为我们提供一种<code>函数接口</code>，一个lambda表达式可以赋值给一个函数接口的对象，然后利用这个对象去调用lambda表达式。</p>
<p>我们可以使用注解<code>@FunctionalInterface</code>来定义一个函数接口，比如这样：</p>
<pre><code class="language-java">@FunctionalInterface
interface LambdaFunc {
    boolean strCompare(String s1, String s2);
}

public class Demo1 {
    public static void main(String[] args) {
        LambdaFunc test = (s1, s2) -&gt; s1.equals(s2);

        System.out.println(test.strCompare(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p>一个函数接口具有一下特点：</p>
<ol>
<li>函数接口是单（抽象）方法接口</li>
<li>接口中抽象方法的返回值就是我们所写的lambda表达式中函数体的返回值</li>
<li>接口中抽象方法的参数就是我们所写的lambda表达式中的参数</li>
<li>只有显式调用<code>函数接口对象.抽象方法</code>并传入相应的参数才会调用对应的lambda表达式</li>
</ol>
<p>其实有些函数接口我们没有必要自己实现，Java8中的<code>java.util.function</code>包中给我们提供了很多的函数接口，比如下面这样：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        BiPredicate&lt;String, String&gt; function = (String s1, String s2) -&gt; s1.equals(s2);

        System.out.println(function.test(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p><code>BiPredicate</code>就是一个<code>function</code>包中内置的一个函数接口，它的抽象方法会接受两个参数，并且返回布尔值：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210104112204.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210104112204.png" loading="lazy"></figure>
<h3 id="方法引用">方法引用</h3>
<p>上面的例子还可以进一步化简：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        BiPredicate&lt;String, String&gt; function = String::equals;

        System.out.println(function.test(&quot;123&quot;, &quot;456&quot;));
    }
}

/*
false

Process finished with exit code 0
*/

</code></pre>
<p>我们把<code>(String s1, String s2) -&gt; s1.equals(s2)</code>简化成了<code>String::equals</code>，这种简化方式称作方法引用，所谓方法引用，就是某个方法的签名和接口的抽象方法签名恰好一致，那么就可以直接把方法引用作为lambda表达式传入接口。</p>
<pre><code>s -&gt; System.out.println(s)  &lt;==&gt;  System.out::println

</code></pre>
<h2 id="stream">Stream</h2>
<p><a href="https://www.youtube.com/watch?v=t1-YZ6bF-g0">Java 8 STREAMS Tutorial - YouTube</a></p>
<h3 id="steam介绍">Steam介绍</h3>
<blockquote>
<p>Stream（流）是Java8中引入的全新API</p>
</blockquote>
<p>Steam本身并不会保存数据，而是类似于一个比较高级的迭代器，数据源中的元素单向传递到流中，不可以往复，只能遍历一次，就像水流一样一去不复返。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175021.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175021.png" loading="lazy"></figure>
<p>在图中涉及到了两个名词：<em>Intermediate operations</em>和<em>Ternimal operations</em>，这是流中的两个重要操作。</p>
<p>Stream分为中间操作(Intermediate operations)和终端操作(Ternimal operations)：</p>
<ul>
<li>中间操作用于对流进行过滤、转换、排序等，比如<code>filter</code>、<code>map</code>、<code>sort</code>，多个中间操作可以被串联起来，一个流经过中间操作之后还是一个流。</li>
<li>终端操作用于将流转换为其他Java对象，比如<code>forEach</code>、<code>collect</code>、<code>reduce</code>等。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175251.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175251.png" loading="lazy"></figure>
<p>一个流中可以有零个或者多个中间操作，对于比较大的数据集：我们应该遵循的一个原则是先使用<code>filter</code>将其过滤，然后再使用其他的中间操作比如<code>map</code>、<code>sort</code>等。</p>
<p>一个流只能有一个终端操作，一些常用的终端操作作用如下：</p>
<ul>
<li><code>forEach</code>：对于对于每个流中的元素使用相同的函数</li>
<li><code>collect</code>：将流中的元素汇总到一个集合里</li>
<li>······</li>
</ul>
<p>在使用stream的时候，基本会遵循下面三个步骤：</p>
<ol>
<li>创建stream</li>
<li>进行流的转换，返回一个新的stream对象（链式操作）</li>
<li>将流转换为其他Java对象</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175912.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210107175912.png" loading="lazy"></figure>
<p>一个流可以通过<code>Collections</code>、<code>Lists</code>、<code>Sets</code>、<code>ints</code>、<code>longs</code>、<code>doubles</code>、<code>arrays</code>、<code>lines of file</code>创建出来。</p>
<h3 id="intermediate-operation">Intermediate operation</h3>
<p>intermediate ooperation（中间操作）：一个流后面可以串联一个或多个中间操作。中间操作可以打开流，对流中的数据进行过滤、映射等，并返回一个新的流供之后操作实用。</p>
<h4 id="map">map</h4>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(1, 2, 3, 4, 5, 6).map(x -&gt; x + 2).forEach(System.out::println);

    }
}

/*
3
4
5
6
7
8

Process finished with exit code 0
*/

</code></pre>
<p>中间操作<code>map</code>用于将一个对象转换为另一个对象，它的签名要求实现一个<code>Function</code>函数接口：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106122927.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106122927.png" loading="lazy"></figure>
<p>这个函数接口的静态方法是接受一个T类型的参数，然后返回一个R类型的对象：</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123014.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123014.png" loading="lazy"></figure>
<p>对于上面的例子，我们做的操作就是把X + 2，所以T和R都是<code>Integer</code>。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(1, 2, 3, 4, 5, 6).map(String::valueOf).forEach(s -&gt; System.out.println(s.getClass().getName()));

    }
}

/*
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String

Process finished with exit code 0

</code></pre>
<p>对于这个例子来说，T就是<code>Integer</code>，R就是<code>String</code>。</p>
<h4 id="filter">filter</h4>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;AI&quot;, &quot;Ankit&quot;, &quot;Kushal&quot;, &quot;Bob&quot;, &quot;Susan&quot;, &quot;Hans&quot;).filter(s -&gt; s.startsWith(&quot;A&quot;)).forEach(System.out::println);

    }
}

/*
AI
Ankit

Process finished with exit code 0

</code></pre>
<p><code>filter</code>是一个过滤器，可以通过给定的条件把流中不符合条件的元素剔除掉，它的签名要求我们实现一个<code>Predicate</code>函数接口，这个函数接口的静态方法接收一个T类型的参数，而返回一个布尔值：</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123958.png" alt="https://cdn.jsdelivr.net/gh/F4ded/blog-pic/blog/20210106123958.png" loading="lazy"></figure>
<p>下一个例子，通过map将流中的每个元素首字母转换为小写，然后再用filter过滤出符合条件的元素：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;AI&quot;, &quot;Ankit&quot;, &quot;Kushal&quot;, &quot;Bob&quot;, &quot;Susan&quot;, &quot;Hans&quot;).map(String::toLowerCase).filter(s -&gt; s.startsWith(&quot;a&quot;)).forEach(System.out::println);

    }
}

/*
ai
ankit

Process finished with exit code 0

</code></pre>
<h4 id="distinct">distinct</h4>
<p>对于流中的元素进行去重，不需要先把其转换为<code>Set</code>，只需要实用<code>distinct</code>中间操作即可：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5, 1);
        list.stream().distinct().forEach(System.out::println);

    }
}

/*
1
2
3
4
5

</code></pre>
<h3 id="ternimal-operations">Ternimal operations</h3>
<p>Ternimal operations（终端操作）：终端操作是流的链式调用的最后一步，被终端操作处理过的流就会变成其他的Java对象。在一个流的链式调用流程中，终端操作只会被调用一次，调用之后流就会关闭。</p>
<h4 id="foreach">forEach</h4>
<p><code>forEach</code>是最常用的一个终端操作，它的参数是一个<code>Consumer</code>函数接口（一元），对流中的每一个元素执行相同的操作，最常见的就是打印流中的每个元素：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        Stream.of(1, 2, 3, 4, 5).map(x -&gt; x + 1).forEach(System.out::println);
    }
}

/*
2
3
4
5
6

</code></pre>
<h4 id="reduce">reduce</h4>
<p>reduce（聚合）操作可以通过聚合函数把流中的元素聚合成一个结果。</p>
<p>reduce方法传入的是一个<code>BinaryOperator</code>接口对象，它的<code>apply</code>方法是一个二元抽象方法，会把传入的两个参数进行运算，并返回运算的结果：</p>
<pre><code class="language-java">T apply(T t, T u);

</code></pre>
<p>下面的代码实用了聚合操作来进行求和：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Integer integer = Stream.of(1, 2, 3, 4, 5).reduce(0, (sum, i) -&gt; sum + i);
        System.out.println(&quot;integer = &quot; + integer);

    }
}

/*
integer = 15

</code></pre>
<p>这样似乎不是很好理解，可以使用for循环来改写一下上面的代码：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) throws Exception {
        int[] arrays = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int i : arrays) {
            System.out.printf(&quot;sum = sum + i = %d + %d\n&quot;, sum, i);
            sum += i;
        }
        System.out.println(sum);
    }

</code></pre>
<p>值得注意的是，我们上面的代码在reduce方法中传入一个初始值0，这样一来，在第一轮中，0就会被作为函数<code>(sum, i) -&gt; sum + i</code>中sum的初始值，而i的初始值就是Stream中的第一个元素<code>1</code>，执行完第一轮的结果为<code>0 + 1 = 1</code>，而这个结果又会作为第二轮中<code>sum</code>的初始值，<code>i</code>的值为Stream中的第二个元素<code>2</code>，如此达到了累加的效果。</p>
<pre><code>sum = sum + i = 0 + 1 = 1
sum = sum + i = 1 + 2 = 3
sum = sum + i = 3 + 3 = 6
sum = sum + i = 6 + 4 = 10
sum = sum + i = 10 + 5 = 15
15

</code></pre>
<p>此外，reduce方法还可以不传入初始值，这样一来，第一轮中的<code>sum</code>的初始值就变为了Stream中的第一个元素<code>1</code>，<code>i</code>的初始值就变成了Stream中的第二个元素<code>2</code>；reduce操作返回的结果也变成了<code>Optional&lt;Integer&gt;</code>对象，需要多调用一个get方法才能得到运算的结果。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) throws Exception {
        Optional&lt;Integer&gt; integer = Stream.of(1, 2, 3, 4, 5).reduce((sum, i) -&gt; sum + i);
        System.out.println(&quot;integer = &quot; + integer.get());
    }
}

/*
integer = 15

</code></pre>
<pre><code class="language-java">sum = sum + i = 1 + 2 = 3
sum = sum + i = 3 + 3 = 6
sum = sum + i = 6 + 4 = 10
sum = sum + i = 10 + 5 = 15
15

</code></pre>
<p>灵活使用reduce，可以达到一些神奇的效果，比如把配置文件中的<code>key=value</code>这种形式的字符串作为键值对储存在Map中：</p>
<pre><code class="language-java">public class Demo2 {
    public static void main(String[] args) {
        List&lt;String&gt; props = List.of(&quot;profile=native&quot;, &quot;debug=true&quot;, &quot;logging=warn&quot;, &quot;interval=500&quot;);
        Map&lt;String, String&gt; propMap = props.stream().map(line -&gt; {
            String[] split = line.split(&quot;=&quot;);
            return Map.of(split[0], split[1]);
        }).reduce(new HashMap&lt;String, String&gt;(), (map, kvmap) -&gt; {
            System.out.println(kvmap.toString() + &quot; -&gt; HashMap&quot;);
            map.putAll(kvmap);
            return map;
        });

        propMap.forEach((key, value) -&gt; {
            System.out.println(key + &quot;: &quot; + value);
        });
    }
}

</code></pre>
<pre><code class="language-java">{profile=native} -&gt; HashMap
{debug=true} -&gt; HashMap
{logging=warn} -&gt; HashMap
{interval=500} -&gt; HashMap
logging: warn
interval: 500
debug: true
profile: native

</code></pre>
<h3 id="other-features">Other features</h3>
<p>Stream具有延时性：只有当终端操作存在的时候，中间的操作才会被执行。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        
        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;).filter(s -&gt; {
            System.out.println(&quot;filter: &quot; + s);
            return true;
        });

    }
}

// 不打印结果

public class Demo1 {
    public static void main(String[] args) {
        
        Stream.of(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;).filter(s -&gt; {
            System.out.println(&quot;filter: &quot; + s);
            return true;
        }).forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));

    }
}

/*
filter: a1
forEach: a1
filter: a2
forEach: a2
filter: a3
forEach: a3
filter: a4
forEach: a4

Process finished with exit code 0
*/

</code></pre>
<p>这样设计是出于性能的考虑，Stream垂直执行可以减少对每个元素的操作个数</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream.of(&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;).map(x -&gt; {
            System.out.println(&quot;map: &quot; + x);
            return x.toUpperCase();
        }).anyMatch(x -&gt; {
            System.out.println(&quot;anyMatch: &quot; + x);
            return x.startsWith(&quot;B&quot;);
        });

    }
}

/*
map: a1
anyMatch: A1
map: b1
anyMatch: B1
*/

</code></pre>
<p><code>anyMatch()</code>方法是一个聚合操作，和中间操作<code>filter()</code>类似，可以传入一个返回值为布尔类型的lambda表达式，当表达式返回值为True的时候就结束循环。</p>
<p>Stream是不能复用的，当调用聚合操作之后流就关闭了，此时如果再调用流则会抛出异常。</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {

        Stream&lt;String&gt; stream = Stream.of(&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;).map(x -&gt; {
            System.out.println(&quot;map: &quot; + x);
            return x.toUpperCase();
        });
        stream.anyMatch(s -&gt; {
            System.out.println(&quot;Stream close&quot;);
            return true;
        });
        stream.filter(s -&gt; true);

    }
}

/*
map: a1
Stream close
Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed
  at java.util.stream.AbstractPipeline.&lt;init&gt;(AbstractPipeline.java:203)
  at java.util.stream.ReferencePipeline.&lt;init&gt;(ReferencePipeline.java:94)
  at java.util.stream.ReferencePipeline$StatelessOp.&lt;init&gt;(ReferencePipeline.java:618)
  at java.util.stream.ReferencePipeline$2.&lt;init&gt;(ReferencePipeline.java:163)
  at java.util.stream.ReferencePipeline.filter(ReferencePipeline.java:162)
  at steam.Demo1.main(Demo1.java:18)
*/

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客重建]]></title>
        <id>https://f4de-bak.github.io/post/bo-ke-chong-jian/</id>
        <link href="https://f4de-bak.github.io/post/bo-ke-chong-jian/">
        </link>
        <updated>2021-02-24T13:08:28.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.f4de.ink/">原博客</a>的本地文件在格硬盘的时候误删，索性直接重建一个。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.f4de.ink/">原博客</a>的本地文件在格硬盘的时候误删，索性直接重建一个。</p>
<!-- more -->
<p>2021，新的起点✨。</p>
]]></content>
    </entry>
</feed>